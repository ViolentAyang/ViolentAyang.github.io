[{"title":"python爬虫","url":"/2021/12/19/python爬虫/","content":"\n# 爬虫介绍\n\n## 什么是爬虫\n\n> 通俗理解：爬虫是一个模拟人类请求网站行为的程序。可以自动请求网页、并把数据抓取下来，然后使用一定的规则提取有价值的数据\n\n## 爬虫应用场景\n\n1. 搜索引擎\n2. 伯乐在线\n3. 慧慧购物助手\n4. 数据分析\n5. 抢票软件等\n\n# HTTP协议介绍\n\n## 认识http协议\n\n> http协议：全称是HyperText Transfer Protocol，中文意思是超文本传输协议，是一种发布接收html页面的方法。服务器端口号是80端口。HTTPS协议：是http协议的加密版本，在http下加入了SSL层。服务器端口号是443端口\n\n## URL详解\n\nURL是Uniform Resource Locator的简写，统一资源定位符。一个URL由以下几个部分组成：\n\n> scheme://host:port/path/?query-string=xxx#anchor\n\n1. scheme：代表的是访问的协议，一般为http或者https以及ftp等\n2. host：主机号，域名，比如www.baidu.com\n3. port：端口号。当你访问一个网站的时候，浏览器默认使用80端口\n4. path：查找路径。比如www.jianshu.com/trending/now，后面的trending/now就是path\n5. query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串\n6. anchor：描点，前端用来做页面定位的。比如一些前后端分离项目，也用描点来做导航。\n\n在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号\n\n+十六进制码值进行编码\n\n## 常见的请求method\n\n在http协议中，定义了八种请求方法，这里介绍两种常用的请求方法，分别是get请求和post请求。\n\n1. get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会用get请求\n2. post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用get方法的请求就一定要改为post请求，这个要视情况而定\n\n| 序号 |  方法   |                             描述                             |\n| :--: | :-----: | :----------------------------------------------------------: |\n|  1   |   GET   |              请求指定的页面信息，并返回实体主体              |\n|  2   |  HEAD   | 类似于get请求，只不过返回的响应中没有具体内容，用于获取报头  |\n|  3   |  POST   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中，POST请求可能会导致新的资源建立和/或已有资源的修改 |\n|  4   |   PUT   |        从客户端向服务器传送的数据取代指定的文档的内容        |\n|  5   | DELETE  |                   请求服务器删除指定的页面                   |\n|  6   | CONNECT |    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器    |\n|  7   | OPTIONS |                  允许客户端查看服务器的性能                  |\n|  8   |  TRACE  |           回显服务器收到的请求，注意用于测试或诊断           |\n\n## 常见的请求头参数\n\n在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在body中（在post请求中），第三个就是把数据放在head中。这里介绍在网络爬虫中经常会用到的一些请求头参数：\n\n1. User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的，如果我们是通过爬虫发送请求，那么我们的User-Agent就是python，这对于那些有反爬机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫\n2. Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么不做相应的响应\n3. Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力直到这两个请求是否来自同一个人。因此这时候就用cookie来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了 \n\n## 常见的响应状态码\n\n1. 200：请求正常，服务器返回正常的返回数据\n2. 301：永久重定向。比如在访问www.jingdong.com的时候会重定向到www.jd.com\n3. 302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登陆，那么就会定向到登录页面\n4. 400：请求的url在服务器上找不到。换句话说就是请求url错误\n5. 403：服务器拒绝访问，权限不够\n6. 500：服务器内部错误。可能是服务器出现bug了1010\n","tags":["网络编程","python","爬虫"],"categories":["python"]},{"title":"算法和数据结构笔记","url":"/2021/12/19/算法和数据结构/","content":"\n# 绪论\n\n## 基本概念和术语\n\n### 数据结构的两个层次\n\n<font color = \"red\">1.逻辑结构</font>\n\n·描述数据元素之间的逻辑关系\n\n·与数据的存储无关，独立于计算机\n\n·是从具体问题抽象出来的数学模型\n\n<font color = \"red\">2.物理结构(存储结构)</font>\n\n·数据元素及其关系在计算机存储器中的结构(存储方式)\n\n·是数据结构在计算机中的表示\n\n<font color = \"green\">逻辑结构与存储结构的关系</font>\n\n·存储结构是逻辑关系的映像与元素本身的映像\n\n·逻辑结构是数据结构的抽象，存储结构是数据结构的实现\n\n·两者综合起来建立了数据元素之间的结构关系\n\n### 逻辑结构的种类\n\n<font color = \"red\">划分方法一</font>\n\n（1）线性结构\n\n> 有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继\n\n**例如：线性表、栈、队列、串**\n\n（2）非线性结构\n\n>一个结点可能有多个直接前驱和直接后继\n\n**例如：树、图**\n\n<font color = \"red\">划分方法二</font>\n\n（1）集合结构:\n\n> 结构中的数据元素之间除了**同属于一个集合**的关系外，无任何其他关系\n\n（2）线性结构：\n\n> 结构中的数据元素之间存在着**一对一**的线性关系\n\n（3）树形结构:\n\n> 结构中的数据元素之间存在着**一对多**的层次关系\n\n（4）图状结构或网状结构\n\n> 结构中的数据元素之间存在着**多对多**的任意关系\n\n### 存储结构的种类\n\n<font color = \"yellow\">顺序存储结构：</font>\n\n> 用一组**连续**的存储单元**依次**存储数据元素，数据元素之间的逻辑关系由元素的**存储位置**来表示\n\n> C语言中用数组来实现顺序存储机构\n\n<font color = \"yellow\">链式存储结构：</font>\n\n> 用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用**指针**来表示\n\n> C语言中用指针来实现链式存储结构\n\n<font color = \"yellow\">索引存储结构：</font>\n\n> 在存储结点信息的同时，还建立附加的**索引表**\n\n> 索引表中的每一项称为一个**索引项**\n\n> 索引项的**一般形式**是:（关键字，地址）\n\n> 关键字是能**唯一标识**一个结点的哪些数据项\n\n> 若每个结点在索引表中都有一个索引项，则该索引表称之为**稠密索引**（Dense Index）。若一组结点在索引表中只对应一个索引项，则该索引表称之为**稀疏索引**（Sparse Index）.\n\n<font color = \"yellow\">散列存储结构：</font>\n\n> 根据结点的关键字直接计算出该结点的存储地址\n\n### 数据类型和抽象数据类型\n\n在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量，常量或表达式，明确说明它们所属的**数据类型**\n\n例如，C语言中：\n\n> 提供int、char、float、double、等基本数据类型\n\n> 数组、结构、共用体、枚举等构造数据类型\n\n> 还有指针，空（void）类型\n\n> 用户也可以用typedef自己定义数据类型\n\n一些最基本数据结构可以用数据类型来实现，如数组、字符串等\n\n而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示\n\n**抽象数据类型**\n\n> 是指一个数学模型以及定义在此数学模型上的一组操作\n\n1.由用户定义，从问题抽象出**数据模型**（逻辑结构）\n\n2.还包括定义在数据模型上的一组**抽象运算**（相关操作）\n\n3.不考虑计算机内的具体存储与运算的具体实现算法\n\n**抽象数据类型的形式定义**\n\n抽象数据类型可用(D,S,P)三元组表示。\n\n其中：\n\n​\tD是数据对象\n\n​\tS是D上的关系集合\n\n​\tP是对D的基本操作集\n\n<font color = \"yellow\">一个抽象数据类型的定义格式：</font>\n\nADT 抽象数据类型名{\n\n​\t数据对象:<数据对象的定义>\n\n​\t数据关系:<数据关系的定义>\n\n​\t基本操作:<基本操作的定义>\n\n}ADT 抽象数据类型名\n\n<font color = \"orange\">其中：数据对象、数据关系的定义用伪代码描述</font>\n\n<font color = \"pink\">基本操作的定义格式为:</font>\n\n\t- 基本操作名（参数表）\n\t- 初始条件：<初始条件描述>\n\t- 操作结果：<操作结果描述>\n\n**基本操作**定义格式说明：\n\n参数表：赋值参数只为操作提供输入值\n\n​\t\t\t  引用参数以&打头，除可提供输入值外，还将返回操作结果\n\n初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之\n\n操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果\n\n抽象数据类型定义举例:Circle的定义\n\nADT 抽象数据类型名{\n\n​\tData\n\n​\t\t数据对象的定义\n\n​\t\t数据元素之间逻辑关系的定义\n\n​\tOperation\n\n​\t\t操作1\n\n​\t\t\t初始条件\n\n​\t\t\t操作结果描述\n\n​\t\t操作2\n\n​\t\t\t......\n\n​\t\t操作n\n\n​\t\t\t......\n\n}\n\nADT Circle{\n\n​\t数据对象: D = {r,x,y|r,x,y均为实数}\n\n​\t数据关系: R = {<r,x,y>|r是半径,<x,y>是圆心坐标}\n\n​\t基本操作:\n\n​\tCircle(&C,r,x,y)\n\n​\t\t操作结构:构造一个圆\n\n​\tdouble Area(C)\n\n​\t\t初始条件:圆已存在\n\n​\t\t操作结构:计算面积\n\n​\tdouble Circumstance(C)\n\n​\t\t初始条件:圆已存在\n\n​\t\t操作结果:计算周长\n\n}\n\n### 抽象数据类型的表示和实现\n\nADT 抽象数据类型名{\n\n​\tData\n\n​\t\t数据对象的定义\n\n​\t\t数据元素之间逻辑关系的定义\n\n​\tOperation\n\n​\t\t操作1\n\n​\t\t\t初始条件\n\n​\t\t\t操作结果描述\n\n​\t\t操作2\n\n​\t\t\t......\n\n​\t\t操作n\n\n​\t\t\t......\n\n}\n\nC语言实现抽象数据类型\n\n用已有的数据类型定义描述它的存储结构\n\n用函数定义描述它的操作\n\n就可以在程序中使用\n\n例如：抽象数据类型“复数”的实现\n\n```c\ntypedef struct{\n\tfloat realpart;         /*实部*/\n    float imagpart;          /*虚部*/\n}Complex\n```\n\n```c\nvoid assign(Complex *A,float real,float imag){    \n\tA->realpart = real;\t\t\t/*实部赋值*/\n    A->imagepart = imag;\t\t/*虚部赋值*/\t\n}\t\t\t\t\t\t\t  /*End of assign()*/\n```\n\n```c\nvoid add(Complex *c,Complex A,Complex B){        /*c = A + B */\n    c->realpart = A.realpart + B.realpart;\t\t/*实部相加*/\n    c->imagpart = A.imagpart + B.imagpart;\t\t/*虚部相加*/\n} \t\t\t\t\t\t\t\t\t\t     /*End of assign()*/\n```\n\n<font color = \"yellow\">注意：Complex是我们定义的一个结构体类型</font>\n\n<font color = \"yellow\">带*：指针变量，它是指向Complex类型的指针</font>\n\n<font color = \"yellow\">不带*：Complex类型的普通变量</font>\n\n```c\n#include <stdlib.h>\ntypedef struct{\n    float realpart;         /*实部*/\n    float imagpart;          /*虚部*/\n}Complex;\nvoid assign(Complex *A,float real,float imag){\n    A->realpart = real;\t\t\t/*实部赋值*/\n    A->imagpart = imag;\t\t/*虚部赋值*/\n}\nvoid add(Complex *c,Complex A,Complex B){        /*c = A + B */\n    c->realpart = A.realpart + B.realpart;\t\t/*实部相加*/\n    c->imagpart = A.imagpart + B.imagpart;\t\t/*虚部相加*/\n}\nint main(void){\n    Complex z1,z2,z3,z4,z;\n    float RealPart,ImagePart;\n    assign(&z1,8.0,6.0);\n    assign(&z2,4.0,3.0);\n    add(&z3,z1,z2);\n    multiply(z1,z2,z4);\n    if(divide(&z,z4,z3)){\n        GetReal(&z,RealPart);\n        GetImag(&z,ImagePart);\n    }\n    return 0;\n}\n```\n\n以上代码由类C语言实现，仍有不全之处，读者自行补充\n\n### 算法和算法分析\n\n \n\n<font color = \"pink\">算法特性:一个算法必须具备以下五个重要特性</font>\n\n- 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在又穷时间内完成\n- 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。\n- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现\n- 输入：一个算法有零个或多个输入\n- 输出：一个算法有一个或多个输出\n\n<font color = \"pink\">算法设计的要求</font>\n\n- 正确性\n- 可读性\n- 健壮性\n- 高效性\n\n<font color = \"pink\">算法效率以下两个方面来考虑：</font>\n\n1.<font color = \"yellow\">时间效率：</font>指的是算法所消耗的**时间**\n\n2.<font color = \"yellow\">空间效率：</font>指的是算法执行的过程中所消耗的**存储空间**\n\n<font color = \"pink\">时间效率和空间效率有时候是矛盾的</font>\n\n<font color = \"orange\">**算法时间效率的度量**</font>\n\n> 算法时间效率可以用一句该算法编制的程序在计算机上执行**所消耗的时间**来度量\n\n<font color = \"orange\">**两种度量方法**</font>\n\n<font color = \"pink\">事后统计：</font>\n\n> 将算法实现后，测算其时间和空间开销\n\n<font color = \"pink\">事前统计：</font>\n\n> 对算法所消耗资源的一种估算方法\n\n<font color = \"orange\">事前分析方法</font>\n\n> 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作(如赋值、比较、移动等)所需的**时间**与算法中进行的简单操作**次数乘积**\n\n算法运行时间 = 一个简单操作所需的时间 × 简单操作次数\n\n**也即算法中每条语句的执行时间之和**\n\n<font color = \"pink\">算法运行时间 = ∑每条语句的执行次数 × 该语句执行一次所需的时间</font>\n\n> 每条语句执行一次所需的时间，一般是由机器而异的。取决于机器的指令性能、速度以及编译的代码质量。是由机器本身软硬件环境决定的，它与算法无关。\n\n> **所以,我们可假设执行每条语句所需的时间均为单位时间。此时对算法的运行时间的讨论就可转化为讨论该算法中所有语句的执行次数，即频度之和了。**\n\n- 例如：两个n×n矩阵相乘的算法可描述为：\n\n  ```c\n  for(i = 1;i <= n; i++){\t\t\t\t//n+1次\n      for(j = 1; j <= n; j++){\t\t //n(n+1)次\n          c[i][j] = 0;\t\t\t     //n*n次\t\n          for(k = 0; k < n; k++){\t\t  //n*n*(n+1)次\n              c[i][j] = c[i][j] + a[i][k]*b[k][j];//n*n*n4次\n          }\n      }\n  }\n  ```\n\n  - 我们把算法所消耗的时间定义为**该算法中每条语句的频度之和**，则上述算法的时间消耗T(n)为：\n\n    **T(n) = 2n³+3n²+2n+1**\n\n为了便于比较不同算法的时间效率，我们仅比较它们的数量级\n\n<font color = \"##D2E9FF\">例如：两个不同的算法，时间消耗分别是：</font>\n\nT1(n) = 10n²     **与**      T2(n) = 5n³\n\n若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为**不等于零的常数**，则成f(n)是T(n)的同数量级函数。记作T(n) = O(f(n))，称 O(f(n))为**算法的渐进时间复杂度**(O是数量级的符号)，简称**时间复杂度**\n\n<font color = \"orange\">**算法时间复杂度定义**</font>\n\n算法中<font color = \"orange\">**基本语句重复执行的次数**</font>是<font color = \"orange\">**问题规模n**</font>的某个函数f(n),算法的时间量度记作：T(n) =  O(f(n))\n\n**基本语句:**\n\n> 算法中重复执行次数和算法的执行时间成正比的语句\n\n> 对算法运行时间的贡献最大\n\n> 执行次数最多\n\n**n越大算法的执行时间越长**\n\n排序：n为记录数\n\n矩阵：n为矩阵的阶数\n\n多项式：n为多项式的项数\n\n集合：n为元素个数\n\n树：n为树的结点个数\n\n图：n为图的定点数或边数\n\n<font color = \"orange\">**定理1.1**</font>\n\n若f(n) = am n^m + am-1 n^m-1 + ...... + a1 n + a0是m次多项式\n\n则T(n) = O(n^m)\n\n<font color = \"pink\">**忽略所有低次幂项和最高次幂系数，体现出增长率的含义**</font>\n\n<font color = \"orange\">**分析算法时间复杂度的基本方法**</font>\n\n1.找出<font color = \"orange\">**语句频度最大**</font>的那条语句作为<font color = \"orange\">**基本语句**</font>\n\n2计算<font color = \"orange\">**基本语句**</font>的频度得到问题规模n的某个函数f(n)\n\n3.取其数量级用符号\"O\"表示\n\n**例1:**\n\n```c\nx = 0; y =0;\nfor (int k = 0;k < n; k++)\n    x ++;\nfor (int i = 0;i < n;i++)\n    for(int j = 0;j < n;j++)\n        y ++;\n```\n\n<font color = \"pink\">**时间复杂度是由嵌套最深语句的频度决定的**</font>\n\n**例2：**\n\n```c\nfor(i = 1ji <= n;i++)\n    for(j = 1;j <= i;j ++)\n        for(k = 1;k <=j; k ++)\n            x = x + 1;\n```\n\n​\t\t\t\t\t\n$$\n语句频度=\\sum_{i=1}^n\\sum_{j=1}^i\\sum_{k=1}^j1=\\sum_{i=1}^n\\sum_{j=1}^ij=\\sum_{i=1}^n\\frac{i(i+1)}{2}\n$$\n\n\n**例3:**\n\n```c\ni = 1；①while(i <= n) ②    i = i * 2;\n```\n\n关键是要找出来执行次数x与n的关系，并形成n的函数\n$$\n若循环执行1次：i = 1*2=2,\\\\\n若循环执行2次：i = 2*2=2^{2},\\\\\n若循环执行3次：i = 2*2*2=2^{3},\\\\\n若循环执行x次：i = 2^{x}\\\\\n设语句②执行次数为x次，由循环条件\\\\\ni \\leq  n\\\\\n∴ 2^{x} \\leq  n\\\\\n∴ x \\leq  {log_2{n}}\\\\\n2^{f(n)} \\leq  n\\\\\n即 f(n) \\leq {log_2{n}}\\\\\n取最大值 f(n) = {log_2{n}}\\\\\n所以该程序段的时间复杂度T(n) = O({log_2{n}})\n$$\n请注意：有的情况下，算法中基本操作重复执行的次数还随问题的**输入数据集**不同而不同\n\n**例：顺序查找，在数组a[i]中查找值等于e的元素，返回其所在位置**\n\n```c\nfor(i = 0;i < n;i ++)    if(a[i] == e) return i+1;return 0;\n```\n\n最好情况：1次\n\n最坏情况：n\n\n平均时间复杂度：O(n)\n\n<font color = \"orange\">**最坏时间复杂度：**</font>指在最坏情况下，算法的时间复杂度\n\n<font color = \"orange\">**平均时间复杂度：**</font>指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间\n\n<font color = \"orange\">**最好时间复杂度：**</font>指在最好情况下，算法的时间复杂度\n\n<font color = \"pink\">**一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长**</font>\n\n> **对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度：**\n\na）加法规则\n\nT(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))\n\nb）乘法规则\n\nT(n) = T1(n) × T2(n) = O(f(n)) × O(g(n)) = O(f(n)×g(n))\n\n### 算法时间效率的比较\n\n> 当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊\n\n时间复杂度T(n)按数量级递增顺序为：\n$$\n常数阶 O(1)\\\\\n对数阶 O({log_2{n}})\\\\\n线性阶 O(n)\\\\\n线性对数阶 O(n {log_2{n}})\\\\\n平方阶 O(n^2)\\\\\n.........\\\\\n立方阶 O(n^k)\\\\\n指数阶 O(2^n)\n$$\n\n### 渐进空间复杂度\n\n- 空间复杂度：算法所需存储空间的度量\n\n记作 S(n) = O(f(n))\n\n其中n为问题的规模\n\n- 算法要占据的空间\n\n算法本身要占据的空间，输入/输出，指令，常数，变量等\n\n算法要是用的**辅助空间**\n\n**例：将一维数组a中的n个数逆序存放到原数组中**\n\n【算法1】\n\n```c\nfor( i = 0; i < n/2; i++){    t = a[i];    a[i] = a[n-i-1];    a[n-i-1] = t;}\n```\n\nS(n) = O(1)\n\n【算法2】\n\n```c\nfor(i = 0;i < n;i ++)    b[i] = a[n-i-1]for(i = 0; i < n;i ++)    a[i] = b[i]\n```\n\nS(n) = O(n)\n\n# 线性表\n\n## 线性表的定义和特点\n\n> **线性表是具有相同特性的数据元素的一个有限序列**\n\n<font color = \"orange\">**线性表（Linear List）：**</font>\n\n​\t由**n(n>=0)**个数据元素(结点)a1,a2,...an组成的**有限序列**\n\n- 其中**数据元素的个数**n定义为表的**长度**\n- 当n=0时称为**空表**\n- 将非空的线性表(n>0)记作：（a1,a2,an)\n- 这里的数据元素ai(1<=i<=n)只是一个抽象的符号，其具体含义在不同的情况下可以不同\n\n### 线性表的例子\n\n例1：分析26个英文字母组成的英文表\n\n(A,B,C,D,......,Z)\n\n数据元素都是字母；元素关系是线性\n\n 例2：分析学生情况登记表\n\n学号\t\t\t姓名\t\t\t性别\t\t\t年龄\t\t\t班级\n\n498623        nww\t\t\t男\t\t\t\t26\t\t\t\t9\n\n### 线性表的逻辑特征\n\n- 从以上例子可看出线性表的逻辑特征是：\n\n  > 在非空的线性表，有且仅有一个开始结点a1,它没有直接前驱，而有且仅有一个直接后继a2;\n\n> 有且仅有一个终端节点an，它没有直接后继，而有且仅有一个直接前驱an-1；\n\n> 其他的内部节点==结点ai(2<=i<=n-1)都有且仅有一个直接前驱ai-1和一个直接后继ai+1\n\n**线性表是一种典型的线性结构**\n\n## 案例引入\n\n### 案例【2.1】一元多项式的运算：实现两个多项式加、减、乘运算\n\nPn(x) = p0 + p1x + p2x^2 + ... + pnx^n\n\n线性表P = (p0,p1,p2......pn)\n\n（每一项的指数i隐含在其系数pi的序号中）\n\n例如P(x) = 10 +5x - 4x^2 + 3x^3 + 2x^4 用数组来表示\n\n| 指数（下标i） |  0   |  1   |  2   |  3   |  4   |\n| :-----------: | :--: | :--: | :--: | :--: | :--: |\n|   系数p[i]    |  10  |  5   |  -4  |  3   |  2   |\n\n<font color = \"yellow\">稀疏多项式</font>\n\nS(x) = 1 + 3x^10000 + 2x^20000\n\n会造成存储空间的很大浪费,怎么办？\n\n|  0   | 10000 | 20000 |\n| :--: | :---: | :---: |\n|  1   |   3   |   2   |\n\n### 案例【2.2】稀疏多项式的运算\n\n多项式非零项的数组表示\n\n(a) A(x) = 7 + 3x + 9x^8 + 5x^17\n\n|  下标i   |  0   |  1   |  2   |  3   |\n| :------: | :--: | :--: | :--: | :--: |\n| 系数a[i] |  7   |  3   |  9   |  5   |\n|   指数   |  0   |  1   |  8   |  17  |\n\n(b) B(x) = 8x + 22x^7 - 9x^8\n\n|  下标i   |  0   |  1   |  2   |\n| :------: | :--: | :--: | :--: |\n| 系数b[i] |  8   |  22  |  -9  |\n|   指数   |  1   |  7   |  8   |\n\nPn(x) = p1x^e1 + p2x^e2 + ... + pmx^em\n\n线性表 P = （(p1,e1),(p2,e2),...(pm,em)）\n\n线性表 A = ((7,0),(3,1),(9,8,),(5,17))\n\n线性表 B = ((8,1),(22,7),(-9,8))\n\n- 创建一个**新数组c**\n\n- 分别从头遍历比较a和b的每一项\n\n  ​\t**指数相同**：对应系数相加，若其和不为0，则在c中增加一个新项\n\n  ​\t**指数不相同**：则将指数较小的项复制到c中\n\n- 一个多项式已遍历完毕时，将另一个剩余项依次复制到c中即可\n\n  \n\n<font color = \"yellow\">顺序存储结构存在问题</font>\n\n- 存储空间分配不灵活\n- 运算的空间复杂度高\n\n<font color = \"orange\">链式存储结构</font>\n\n## 线性表的类型定义\n\n### 基本操作：\n\n**InitList(&L)**\n\n - 操作结果：构造一个空的线性表L\n\n**DestoryList(&L)**\n\n- 初始条件：线性表已经存在\n- 操作结构：销毁线性表L\n\n**ClearList(&L)**\n\n- 初始条件：线性表L已经存在\n- 操作结果：将线性表L重置为空表\n\n**ListEmpty(L)**\n\n- 初始条件：线性表L已经存在\n- 操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE4\n\n**ListLength(L)**\n\n- 初始条件：线性表L已经存在\n- 操作结果：返回线性表L中的数据元素个数\n\n**GetElem(L,i,&e)**\n\n- 初始条件：线性表L已经存在，1<=i<=ListLength(L)\n- 操作结果：用e返回线性表L中第i个数据元素的值\n\n**LocateElem(L,e,compare())**\n\n- 初始条件：线性表L已经存在，compare()是数据元素判定函数\n- 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0\n\n**PriorElem(L.cur_e,&pre_e)**\n\n- 初始条件：线性表L已经存在\n- 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义\n\n**NextElem(L,cur_e,&next_e)**\n\n- 初始条件：线性表L已经存在\n- 操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义\n\n**ListInsert(&L,i,e)**\n\n- 初始条件：线性表L已经存在，1<=i<=ListLengtgh(L) + 1\n- 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加一\n\n**ListDelete(&L,i,&e)**\n\n- 初始条件：线性表L已经存在，1<=i<=ListDelete(&L,i,&e)\n- 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一\n\n**ListTraverse(&L,visited())**\n\n- 初始条件：线性表L已经存在\n- 操作结果：依次对线性表中的每个元素调用visited()\n\n## 线性表的顺序表示和实现\n\n <font color = \"pink\">用一维数组表示顺序表</font>\n\n <font color = \"pink\">用一变量表示顺序表的长度属性</font>\n\n```c\n#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量typedef int Element;typedef struct{    ElemType elem[LIST_INIT_SIZE];    int length; //当前长度}SqList;\n```\n\n### 多项式的顺序存储结构类型定义\n\nPn(x) = p1x^e1 + p2x^e2 + ... +pmx^em\n\n```c\n#define MAXSIZE 1000    //多项式可能达到的最大长度typedef struct{\t\t   //多项式非零项的定义    float p;    \t   //系数    int e;\t\t\t  //指数}Polynomial;typedef struct{    Polynomial *elem;  //存储空间的基地址    int length;\t\t  //多项式当前项的个数}SqList;\t\t      //多项式的顺序结构类型为SqList\n```\n\n### 图书表的顺序存储结构类型定义\n\n```c\n#define MAXSIZE 10000  //图书表可能达到的最大长度typedef struct{\t\t  //图书信息定义    char no[20];\t  //图书ISBN    char name[50];\t  //图书名字    float price;\t  //图书价格}Book;typedef struct{    Book *elem;\t\t  //存储空间的基地址    int length;\t\t  //图书表中当前图书个数}SqList;\t\t\t //图书表的顺序存储结构类型为SqList\n```\n\n### 补充：元素类型说明\n\n顺序表类型定义:\n\n```c\ntypedef struct{    //typedef char ElemType;    ElemType data[];//ElemType 可以是任意类型，所以也可以是自定义的结构体类型，即结构体数组    int length;}SqList; //顺序表类型\n```\n\n### 补充：数组静态分配\n\n```c\ntypedef struct{    ElemType data[MaxSize];    int length;}SqList; //顺序表类型\n```\n\n### 补充：数组动态分配\n\n```c\ntypedef struct{    ElemType *data;    int length;}SqList; //顺序表类型//动态分配内存SqList L;L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);\n```\n\n ### 补充：C语言的内存动态分配\n\n- malloc(m)函数，开辟m字节长度地址空间，并返回这段空间的首地址\n- sizeof(x)运算，计算变量x的长度\n- free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量\n\n<font color = \"orange\">需要加载头文件:<stdlib.h ></font>\n\n ### 顺序表基本操作实现\n\n线性表的基本操作\n\n- InitList(&L) //初始化操作，建立一个空的线性表L\n- Destory(&L) //销毁已存在的线性表L\n- ClearList(&L) //将线性表清空\n- **ListInsert(&L,i,e) ** //在线性表L中的第i个位置插入新元素e\n- **ListDelete(&L,i,&e)** //删除线性表L中的第i个位置元素，用e返回\n- IsEmpty(L) //若线性表为空，则返回True，否则False\n- ListLength(L) //返回线性表L的元素个数\n- **LocateElem(L,e)**  //L中查找与给定值e相等的元素，若成功返回该元素在表中的序号，否则返回0\n- GetElem(L,i,&e) //将线性表L的第i个位置元素返回给e\n\n### 补充：操作算法中用到的预定义常量和类型\n\n```c\n//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//status 是函数的类型，其值是函数结果状态代码typedef int Status;typedef char ElemType;\n```\n\n### 顺序表基本操作的实现\n\n【算法2.1】线性表L的初始化(参数用引用)\n\n```c\nStatus InitList_Sq(SqList &L){ //构造一个空的顺序表L    L.elem = (ElemType*)malloc(sizeof(ElemType)*MaxSize); //为顺序表分配空间    if(!L.elem) exit(OVERFLOW); //存储分配失败    L.length = 0; //空表长度为0    return OK;}\n```\n\n【算法2.2】销毁线性表\n\n```c\nvoid Destory(SqList &L){    if(L.elem) free(L.elem); //释放存储空间}\n```\n\n【算法2.3】清空线性表\n\n```c\nvoid ClearList(SqList &L){    L.length = 0; //将线性表的长度置为0}\n```\n\n【算法2.4】求线性表的长度\n\n```c\nint GetLength(SqList L){    return L.length;}\n```\n\n【算法2.5】判断线性表是否为空\n\n```c\nint IsEmpty(SqList L){    if (L.length == 0) return 1;    else return 0;}\n```\n\n【算法2.6】顺序表的取值(根据位置i获取相应位置数据元素的内容)\n\n```c\nint GetElem(SqList L,int i,ElemType &e){    if (i<1||i>L.length) return ERROR; //判断i值是否合理，若不合理，则返回ERROR    e = L.elem[i-1]; //第i-1单元存储着第i个数据    return OK;}\n```\n\n### 顺序表上的查找操作\n\n<font color = \"Orange\">按值查找：</font>\n\n例如：在图书表中，按照给定书号进行查找，确定是否存在该图书\n\n如果存在：输出是第几个元素\n\n如果不存在：输出0\n\n【算法2.7】顺序表的查找\n\n- 在线性表L中查找与指定值e相同的数据元素的位置\n- 从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0\n\n```c\nint LocateElem(SqList L,ElemType e){    //在线性表L中查找值为e的数据元素，返回其序号(是第几个元素)    for(i = 0; i < L.length ;i ++){        if(L.elem[i] == e){            return i+1;\t//查找成功，返回序号        }        return 0;// 查找失败，返回0    }}\n```\n\n```c\nint LocateElem(SqList L,ElemType e){     //在线性表L中查找值为e的数据元素，返回其序号(是第几个元素)    i = 0；    while(i<L.length&&L.elem[i]!=e) i++;    if(i<L.length) return i+1; //查找成功，返回序号    return 0;// 查找失败，返回0}\n```\n\n<font color = \"orange\">顺序表的查找算法分析：</font>\n\n因为查找算法的基本操作为：将记录的关键字同给定值进行比较\n\n​\t基本操作：L.elem[i] == e\n\n平均查找长度ASL(Average Search Length):\n\n​\t为确定记录在表中位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的平均查找长度\n$$\nASL = \\sum_{i = 1}^nP_iC_i\n$$\n 【算法2.8】顺序表的插入\n\n<font color = \"pink\">算法思想：</font>\n\n- 判断插入位置i是否合法\n- 判断顺序表的存储空间是否已满，若已满返回ERROR\n- 将第n至第i位的元素依次向后移动一个位置，空出第i个位置\n- 将要插入的新元素e放入第i个位置\n\n```c\nStatus ListInsert_Sq(SqList &L,int i,ElemType e){    ① if(i<1||i>L.length+1) return ERROR;//i值不合法    ② if(L.length == MAXSIZE) return ERROR;//当前存储空间已满    ③ for(j = L.length-1;j>=i-1;j--){      \tL.elem[j+1] = L.elem[j];//插入位置及之后的元素后移    }    ④ L.elem[i-1] = e;//将新元素e放入第i个位置    ⑤ L.length ++;//表长加一}\n```\n\n  【算法2.9】顺序表的删除\n\n<font color = \"pink\">算法思想：</font>\n\n- 判断删除位置i是否合法（合法值为1<=i<=n）\n- 将欲删除的元素保留在e中\n- 将第i+1至第n位的元素依次向前移动一个位置\n- 表长减一，删除成功返回OK\n\n```c\nStatus ListDelete_Sq(SqList &L,int i){    ① if(i<1||i>L.length) return ERROR;//i值不合法    ② for(j = i;j<=L.length-1;j++){        L.elem[j-1] = L.elem[j];//被删除元素之后的元素前移    }    ④ L.length--;//表长减一    return OK;}\n```\n\n## 小结\n\n### 顺序表(线性表的顺序存储结构)的特点\n\n（1）利用数据元素的存储位置表示线性表中的相邻数据元素之间的前后关系，即线性表得逻辑结构与存储结构一致\n\n（2）在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等\n\n- 这种存取元素的方法被称为**随机存取法**\n\n### **线性表的基本操作**\n\n- InitList(&L) //初始化操作，建立一个空的线性表L\n- Destory(&L) //销毁已存在的线性表L\n- ClearList(&L) //将线性表清空\n- **ListInsert(&L,i,e) ** //在线性表L中的第i个位置插入新元素e\n- **ListDelete(&L,i,&e)** //删除线性表L中的第i个位置元素，用e返回\n- IsEmpty(L) //若线性表为空，则返回True，否则False\n- ListLength(L) //返回线性表L的元素个数\n- **LocateElem(L,e)**  //L中查找与给定值e相等的元素，若成功返回该元素在表中的序号，否则返回0\n- GetElem(L,i,&e) //将线性表L的第i个位置元素返回给e\n\n### 优点\n\n- 存储密度大（结点本身所占存储量/结点结构所占存储量）\n- 可以随机存取表中任一元素\n\n### 缺点\n\n- 在插入、删除某一元素时，需要移动大量元素\n- 浪费存储空间\n- 属于静态存储形式，数据元素的个数不能自由扩充\n\n## 线性表的链式表示和实现\n\n**链式存储结构**\n\n> 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n\n线性表的链式表示又称为**非顺序映像**或**链式映像**\n\n- 用一组**物理位置任意的存储单元**来存放线性表的数据元素\n- 这组存储单元既可以是**连续的**，也可以是**不连续的**，甚至是零散分布在内存中任意位置上的\n- 链表中元素的**逻辑次序和物理次序不一定相同**\n\n**例**\n\n线性表（赵，钱，孙，李，周，吴，郑，王）\n\n<font size = 25>顺序表</font>\n\n| 存储地址 | 存储状态 |\n| :------: | :------: |\n|   0031   |    赵    |\n|   0033   |    钱    |\n|   0035   |    孙    |\n|   0037   |    李    |\n|   0039   |    周    |\n|   0041   |    吴    |\n|   0043   |    郑    |\n|   0045   |    王    |\n\n<font size = 25>链表</font>\n\n| 存储地址 | 数据域 | 指针域 |\n| :------: | :----: | :----: |\n|   0001   |   李   |  0043  |\n|   0007   |   钱   |  0013  |\n|   0013   |   孙   |  0001  |\n|   0019   |   王   |  NULL  |\n|   0025   |   吴   |  0037  |\n|   0031   |   赵   |  0007  |\n|   0037   |   郑   |  0019  |\n|   0043   |   周   |  0025  |\n\n### 与链式存储有关的术语\n\n1.**结点**：数据元素的存储映像。由数据域和指针域两部分组成\n\n2.**链表**：n个结点由**指针链**组成一个链表\n\n​\t\t\t它是线性表的链式存储映像，称为线性表的链式存储结构\n\n3.<font color = \"pink\">单链表、双链表、循环链表：</font>\n\n> 结点只有一个指针域的链表，称为**单链表**或线性链表\n\n> 结点有两个指针域的链表，称为**双链表**\n\n> 首尾相接的链表称为**循环链表**\n\n4.<font color = \"pink\">头指针、头结点和首元结点：</font>\n\n<font color = \"pink\">头指针：</font>是指向链表中第一个结点的指针\n\n<font color = \"pink\">首元结点：</font>是指向链表中存储第一个数据元素a1的结点\n\n<font color = \"pink\">头结点：</font>是在链表的首元结点之前附设的一个结点\n\n### 如何表示空表？\n\n- 无头结点时，**头指针为空**时表示空表\n- 有头结点时，**当头结点的指针域为空**时表示空表\n\n### 在链表中设置头结点有什么好处？\n\n1 便于**首元结点**的处理\n\n​\t首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理\n\n2 便于**空表和非空表**的统一处理\n\n​\t无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了\n\n### 头结点的**数据域**内装的是什么？\n\n头结点的**数据域**可以为空，也可存放**表长度**等附加信息，但此结点不能计入链表长度值\n\n### 链表的特点\n\n- 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n- 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费时间不等。**这种存取元素的方法被称为顺序存取法**\n\n> 单链表是由表头唯一确定，因此单链表可以用**头指针**的名字来命名，若头指针名是L，则把链表称为表L\n\n<font color = \"pink\">单链表的存储结构：</font>\n\n```c\ntypedef struct Lnode{//声明结点的类型和指向结点的指针类型    ElemType data;//结点的数据域    struct Lnode *next;//结点的指针域}Lnode,*LinkList;//LinkList为指向结构体Lnode的指针类型\n```\n\n**定义一个链表L：**LinkList L;\n\n**定义结点指针p：**LNode *p；LinkList p；\n\n<font color = \"orange\">例如：存储学生学号、姓名、成绩的单链表结点类型定义如下：</font>\n\n```c\ntypedef struct student{    char num[8];//数据域    char name[8];//数据域    int score;//数据域    struct student *next;//指针域}Lnode,*LinkList;\n```\n\n### 单链表基本操作的实现\n\n**单链表的初始化**\n\n> 即构造一个空表\n\n【算法步骤】\n\n1. 生成新结点作头结点，用头指针L指向头结点\n2. 将头结点的指针域置空\n\n【算法描述】\n\n```c\ntypedef struct Lnode{//声明结点的类型和指向结点的指针类型    ElemType data;//结点的数据域    struct Lnode *next;//结点的指针域}LNode,*LinkList;//LinkList为指向结构体Lnode的指针类型\n```\n\n```c\nStatus InitList L(LinkList &L){    L = (LinkList)malloc(sizeof(LNode));    L->next = NULL;}\n```\n\n【补充算法1】**判断链表是否为空**\n\n**空表**：链表中无元素，称为空链表(头指针和头结点仍然在)\n\n【算法思路】判断头结点指针域是否为空\n\n```c\nint ListEmpty(LinkList L){//若L为空表，则返回1，否则返回0    if(L->next)//非空        return 0;    else        return 1;}\n```\n\n【补充算法2】单链表的销毁：链表销毁后不存在\n\n【算法思路】从头指针开始，依次释放所有结点\n\n```c\n Status DestoryList L(LinkList &L){//销毁单链表L     Lnode *p;//或LinkList p; \t while(L){         p = L;         L = L->next;         free(p);     }     return OK; }\n```\n\n【补充算法3】清空链表\n\n链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)\n\n【算法思路】依次释放所有结点，并将头结点指针域设置为空\n\n```c\n \n```\n\n\n\n## 顺序表和链表的比较\n\n## 线性表的应用\n\n## 案例分析与实现\n","tags":["算法","数据结构"],"categories":["算法和数据结构"]},{"title":"Java集合框架","url":"/2021/12/19/Java集合框架/","content":"\n# 集合体系结构\n\n        单列集合 collection\n           可重复list\n               ArrayList LinkedList\n           不可重复set\n              HashSet TreeSet\n        双列集合 map\n               HashMap\n\n# Collection 集合概述\n\n        1.是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素\n        2.JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现\n        创建Collection对象\n        1.多态的方式\n        2.具体的实现类ArrayList\n\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class day2collection集合概述和引用 {\n    public static void main(String[] args) {\n        Collection<String> c = new ArrayList<String>();\n        //添加元素 ：boolean add(E e)\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        System.out.println(c);\n    }\n}\n```\n\n## 集合常用方法\n    Collection集合常用方法\n    boolean add(E e) 添加元素\n    boolean remove(Object o) 从集合中移除指定的元素\n    void clear() 清空集合中的元素\n    boolean contains(Object o) 判断集合中是否包含指定元素\n    boolean isEmpty() 判断集合是否为空\n    int size() 集合的长度，也就是集合中元素的个数\n    alt+7快捷键打开一个窗口 能够看到类的信息\n```java\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class day3Collection集合常用方法 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Collection<String> c = new ArrayList<>();\n        //boolean add(E e) 添加元素\n        /*System.out.println(c.add(\"hello\"));\n        System.out.println(c.add(\"world\"));\n        System.out.println(c.add(\"world\"));*/\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        //boolean remove(Object o) 从集合中移除指定的元素\n        System.out.println(c.remove(\"world\"));\n        System.out.println(c.remove(\"jaba\"));\n        //void clear() 清空集合中的元素\n        c.clear();\n        //boolean contains(Object o) 判断集合中是否包含指定元素\n        System.out.println(c.contains(\"world\"));\n        //boolean isEmpty() 判断集合是否为空\n        System.out.println(c.isEmpty());\n        //int size() 集合的长度，也就是集合中元素的个数\n        System.out.println(c.size());\n        //输出集合对象\n        System.out.println(c);\n    }\n}\n\n```\n\n## Collection集合的遍历\n\tIterator: 迭代器，集合的专用遍历方式\n\t *Iterator<E> iterator(): 返回此集合中元素的迭代器，通过集合的iterator()方法得到\n\t*迭代器是通过集合的iterator()方法得到的，所以我们说他是依赖于集合而\t\t存在的\n\tIterator中的常用方法\n\tE next():返回迭代中的下一个元素\n\tboolean hasNext(): 如果迭代具有更多元素，则返回true\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class day4Collection集合的遍历 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Collection<String> c = new ArrayList<>();\n        //添加元素\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        //Iterator<E> iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到\n        Iterator<String> it = c.iterator();\n        /*public Iterator<E> iterator() {\n            return new ArrayList.Itr();\n        }\n        private class Itr implements Iterator<E> {\n            }*/\n        /*System.out.println(it.next());\n        System.out.println(it.next());\n        System.out.println(it.next());*/\n//        if (it.hasNext()){\n//            System.out.println(it.next());\n//        }if (it.hasNext()){\n//            System.out.println(it.next());\n//        }if (it.hasNext()){\n//            System.out.println(it.next());\n//        }if (it.hasNext()){\n//            System.out.println(it.next());\n//        }\n        while(it.hasNext()){\n//            System.out.println(it.next());\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n\n```\n\n## 集合使用步骤\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class day5集合使用步骤 {\n    public static void main(String[] args) {\n        Collection<String> c = new ArrayList<>();\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        Iterator<String> it = c.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## Collection存储学生对象并遍历\n\n> 需求：创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n>\n> 思路： \n> ①定义学生类 \n> ②创建Collection对象\n> ③创建学生对象\n> ④把学生添加到集合 \n> ⑤遍历集合（迭代器方式）\n```java\npublic class day6Collection存储学生对象并遍历 {\n    public static void main(String[] args) {\n        //创建Collection集合对象\n        Collection<day6Student> c = new ArrayList<>();\n        //创建学生对象\n        day6Student s1 = new day6Student(\"杨要想\",19);\n        day6Student s2 = new day6Student(\"率秀气\",18);\n        day6Student s3 = new day6Student(\"张帅\",20);\n        //把学生添加到集合\n        c.add(s1);\n        c.add(s2);\n        c.add(s3);\n        //遍历集合（迭代器方法）\n        Iterator<day6Student> it = c.iterator();\n        while(it.hasNext()){\n            day6Student s = it.next();\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n# List集合概述和特点\n\n\tList集合概述\n\t ·有序集合（也称为序列），用户可以精准控制列表中每个元素的插入位置。用户可以\t通过整数索引访问元素，并搜索列表中的元素。\n\t·与Set集合不同，列表通常允许重复的元素\n\t\n\tList集合特点\n\t·有序：存储和取出的元素顺序一致\n\t ·可重复：存储的元素可以重复\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class day1List集合概述和特点 {\n    public static void main(String[] args) {\n        //创建集合元素\n        List<String> list = new ArrayList<>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        list.add(\"world\");\n        //直接输出集合对象\n        System.out.println(list);\n        //遍历集合\n        Iterator<String> it = list.listIterator();\n        while(it.hasNext()){\n            System.out.println(it.next());\n        }\n    }\n}\n```\n\n## List集合特有方法\n\n\tvoid add(int index,E element) 在此集合的指定位置插入指定的元素\n\tE remove(int index) 删除指定索引处的元素，返回被删除的元素\n\tE set(set index,E element) 修改指定索引处的元素，返回被修改的元素\n\tE get(int index) 返回指定索引处的元素\n\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class day2List特有方法 {\n    public static void main(String[] args) {\n        //创建集合元素\n        List<String> list = new ArrayList<>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        //void add(int index,E element) 在此集合的指定位置插入指定的元素\n        list.add(1,\"javaee\");\n        //list.add(11,\"als\") 越界异常\n        //E remove(int index) 删除指定索引处的元素，返回被删除的元素\n        list.remove(1);\n        //E set(set index,E element) 修改指定索引处的元素，返回被修改的元素\n        list.set(2,\"lzy\");\n        //E get(int index) 返回指定索引处的元素\n        System.out.println(list.get(1));\n        //输出集合对象\n        System.out.println(list);\n        //遍历集合\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n    }\n}\n\n```\n\n> 需求：创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n\t①定义学生类\n\t②创建list对象\n\t③创建学生对象\n\t④把学生添加到集合\n\t⑤遍历集合（迭代器方式，for循环方式）\n\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class day3List集合存储学生对象并遍历 {\n    public static void main(String[] args) {\n        //创建list集合对象\n        List<day3Student> list  = new ArrayList<>();\n        //创建学生对象\n        day3Student s1 = new day3Student(\"张三\",66);\n        day3Student s2 = new day3Student(\"李四\",96);\n        day3Student s3 = new day3Student(\"王五\",86);\n        //把学生添加到集合\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n        //遍历集合\n        Iterator<day3Student> it = list.listIterator();\n        while(it.hasNext()){\n            day3Student s = it.next();\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            day3Student c = list .get(i);\n            System.out.println(c.getName() + \",\" + c.getAge());\n        }\n    }\n}\n\n```\n\n## 并发修改异常\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n//遍历集合 得到每一个元素 看有没有world这个元素 如果有 我就添加一个 javaee 元素\n//ConcurrentModificationExceptionh 当不允许这样的修改时，可以通过检测到对象的并发修改的方法来抛出此异常\n\npublic class day4并发修改异常 {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<String> list = new ArrayList<>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        //遍历集合 得到每一个元素 看有没有world这个元素 如果有 我就添加一个 javaee 元素\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            if (s.equals(\"world\")){\n                list.add(\"javaee\");\n            }\n        }\n//        for (int i = 0; i < list.size(); i++) {\n//            String s = list.get(i);\n//            if (s.equals(\"world\")){\n//                list.add(\"javaee\");\n//            }\n//        }\n        //输出集合对象\n        System.out.println(list);\n    }\n}\n\n```\n\n## ListIterator:列表迭代器\n\n\t·通过LIst集合的listIterator()方法得到，所以说它是List集合特有的迭代器\n\t·用于允许程序员沿任一方向遍历列表的的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置\n\n## ListIterator中的常用方法\n\n\t·E next():返回迭代中的下一个元素\n\t·boolean hasNext():如果迭代具有更多元素，则返回true\n\t·E previous():返回列表中的上一元素\n\t·boolean hasPrevious():如果此迭代器在相反方向遍历列表时具有更多元素，则返回true\n\t·void add(E e):将指定的元素插入列表`\n\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class day5列表迭代器 {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<String> list = new ArrayList<>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        //通过list集合的listiterator()方法得到\n//        ListIterator<String> lit = list.listIterator();\n//        while (lit.hasNext()){\n//            String s = lit.next();\n//            System.out.println(s);\n//        }\n//        while (lit.hasPrevious()){\n//            String s = lit.previous();\n//            System.out.println(s);\n//        }\n        //获取列表迭代器\n        ListIterator<String> it = list.listIterator();\n        while(it.hasNext()){\n            String s= it.next();\n            if (s.equals(\"world\")){\n                it.add(\"javaee\");\n            }\n        }\n        System.out.println(list);\n    }\n}\n\n```\n\n## 增强for循环\n\n```java\n//增强for：简化数组和Collection集合的遍历\n//·实现Iterator接口的类允许其对象成为增强型for语句的目标\n//·它是JDK5之后出现的，其内部原理是一个Iterator迭代器\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n//增强for的格式\n//·格式：\n//  for(元素数据类型变量名:数组或者Collection集合){\n//      在此处使用变量即可，该变量就是元素\n//  }\npublic class day6增强for循环 {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,4,5};\n        for (int i :arr){\n            System.out.println(i);\n        }\n        System.out.println(\"--------------------\");\n        String[] strArray = {\"hello\",\"world\",\"java\"};\n        for (String s:strArray){\n            System.out.println(s);\n        }\n        System.out.println(\"--------------------\");\n        List<String> list = new ArrayList<>();\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        for (String s:list){\n            System.out.println(s);\n        }\n        //内部原理是一个Iterator迭代器\n        for (String s:list){\n            if (s.equals(\"world\")){\n                list.add(\"javaee\");\n            }\n        }\n        System.out.println(\"--------------------\");\n        Iterator<String> it = list.iterator();\n        while (it.hasNext()){\n            System.out.println(it.next());\n        }\n        System.out.println(\"-------------------\");\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n        System.out.println(\"-------------------\");\n\n    }\n}\n\n```\n\n## List集合的子类特点\n\n\tList集合常用子类:ArrayList，LinkedList\n\tArrayList:底层数据结构是数组，查询快，增删慢\n\tLinkedList:底层数据结构是链表，查询慢，增删快\n\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class day9List集合的子类特点 {\n    public static void main(String[] args) {\n        List<String> array = new ArrayList<>();\n        array.add(\"hello\");\n        array.add(\"world\");\n        array.add(\"java\");\n        //迭代器\n        Iterator<String> it = array.listIterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        //for循环\n        for (int i = 0; i < array.size(); i++) {\n            System.out.println(array.get(i));\n        }\n        //增强for\n        for(String s : array){\n            System.out.println(s);\n        }\n        System.out.println(\"----------------\");\n        List<String> linkedstring = new LinkedList<>();\n        linkedstring.add(\"hello\");\n        linkedstring.add(\"world\");\n        linkedstring.add(\"java\");\n        //增强for\n        for(String s : linkedstring){\n            System.out.println(s);\n        }\n    }\n}\n\n```\n\n## LinkedList集合的特有功能\n\n\tpublic void addFirst(E e) 在该列表开头插入指定的元素\n\tpublic void addLast(E e) 将制定元素追加到此列表的末尾\n\tpublic E getFirst() 返回此列表中的第一个元素\n\tpublic E getLast() 返回此列表中的最后一个元素\n\tpublic E removaFirst() 从此列表中删除并返回第一个元素\n\tpublic E removaLast() 从此列表中删除并返回最后一个元素\n\n\n```java\nimport java.util.LinkedList;\n\npublic class day10LinkedList集合的特有功能 {\n    public static void main(String[] args) {\n        //创建集合对象\n        LinkedList<String> linkedlist = new LinkedList<>();\n\n        linkedlist.add(\"hello\");\n        linkedlist.add(\"world\");\n        linkedlist.add(\"java\");\n        //public void addFirst(E e) 在该列表开头插入指定的元素\n        linkedlist.addFirst(\"javase\");\n        //public void addLast(E e) 将制定元素追加到此列表的末尾\n        linkedlist.addLast(\"javaee\");\n        //public E getFirst() 返回此列表中的第一个元素\n        System.out.println(linkedlist.getFirst());\n        //public E getLast() 返回此列表中的最后一个元素\n        System.out.println(linkedlist.getLast());\n        //public E removaFirst() 从此列表中删除并返回第一个元素\n        System.out.println(linkedlist.removeFirst());\n        //public E removaLast() 从此列表中删除并返回最后一个元素\n        System.out.println(linkedlist.removeLast());\n        System.out.println(linkedlist);\n    }\n}\n\n```\n\n@[TOC](文章目录)\n# Set\n\tSet集合概述和特点\n\tSet集合特点：\n\t  不包含重复元素的集合\n\t  没有带索引的方法，所以不能使用普通for循环遍历\n\n```python\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class day1Set集合概述和特点 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Set<String> set = new HashSet<>();\n        //添加元素\n        set.add(\"hello\");\n        set.add(\"world\");\n        set.add(\"java\");\n        //不包含重复元素\n        set.add(\"world\");\n        //遍历\n        for (String s : set){\n            System.out.println(s);\n        }\n    }\n}\n\n```\n\n## 哈希值:\n\n是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n\n\tObject类中有一个方法可以获取对象的哈希值\n\t  public int hashCode();返回对象的哈希码值\n```python\npublic class day2哈希值 {\n    public static void main(String[] args) {\n        //创建学生对象\n        day2Student s1 = new day2Student(\"林青霞\",30);\n        //同一个对象多次调用hashCode()这个方法返回的哈希值是相同的\n        System.out.println(s1.hashCode());//1956725890\n        System.out.println(s1.hashCode());//1956725890\n        System.out.println(\"---------------------------\");\n        //默认情况下，不同对象的哈希值是不相同的\n        //通过方法重写，可以实现不同对象的哈希值是相同的\n        day2Student s2 = new day2Student(\"林青霞\",30);\n        System.out.println(s2.hashCode());//356573597\n\n        System.out.println(\"-------------------------\");\n\n        System.out.println(\"hello\".hashCode());//99162322\n        System.out.println(\"world\".hashCode());//113318802\n        System.out.println(\"java\".hashCode());//3254818\n\n        System.out.println(\"world\".hashCode());//113318802\n\n        System.out.println(\"重地\".hashCode());//1179395\n        System.out.println(\"通话\".hashCode());//1179395\n    }\n}\n\n\n\n```\n\n\n\n## HashSet集合概述和特点\n\n\n\n\t  底层数据结构是哈希表\n\t  对集合的迭代顺序不保证，也就是说不保证存储和取出的元素顺序一致\n\t  没有带索引的方法，所以不能使用普通for循环遍历\n\t  由于是set集合，所以是不包含重复元素的集合\n\n```python\nimport java.util.HashSet;\n\npublic class day3HashSet集合概述和特点 {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> hs = new HashSet<>();\n        //添加元素\n        hs.add(\"hello\");\n        hs.add(\"world\");\n        hs.add(\"java\");\n\n        hs.add(\"world\");\n        //遍历\n        for (String s : hs){\n            System.out.println(s);\n        }\n    }\n}\n\n```\n\n ## HashSet集合保证元素唯一性源码分析\n\n\n\n```python\n//创建集合对象\nHashSet<String> hs = new HashSet<>();\n//添加元素\nhs.add(\"hello\");\nhs.add(\"world\");\nhs.add(\"java\");\n------------------------------------\n\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\npubli c V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //如果哈希表未初始化，就对其进行初始化\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //根据对象的哈希值计算对象的存储位置，如果该位置没有元素，就存储元素\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        /*\n            存入的元素和以前的元素比较哈希值\n                如果哈希值不同，会继续向下执行，把元素添加到集合\n                如果哈希值相同，会调用对象的equals()方法比较\n                    如果返回false，会继续向下执行，把元素添加到集合\n                    如果返回true，说明元素重复，不存储\n        */\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n## 哈希表\n\n JDK8之前，底层采用数组+链表实现，可以说是一个元素为链表的数组\n JDK8之后，在长度比较长的时候，底层实现了优化\n\n> //需求:创建一个存储学生对象的系统，存储多个学生对象，使用程序实现在控制台遍历\n> //要求:学生对象的成员变量相同，我们就认为是同一个对象\n> //\n> //思路:\n> //1.定义学生类\n> //2.创建HashSet集合对象\n> //3.创建学生对象\n> //4.把学生添加到集合\n> //5.遍历集合(加强for循环)\n> //6.在学生类中重写两个方法 hashcode()和equals() 自动生成即可 alt+insert\n\n```python\nimport java.util.HashSet;\n\npublic class day6HashSet集合存储学生对象并遍历 {\n    public static void main(String[] args) {\n        //创建hashset集合对象\n        HashSet<day6Student> hs = new HashSet<>();\n        //创建学生对象\n        day6Student s1 = new day6Student(\"林青霞\",30);\n        day6Student s2 = new day6Student(\"张曼玉\",35);\n        day6Student s3 = new day6Student(\"王祖贤\",33);\n\n        day6Student s4 = new day6Student(\"王祖贤\",33);\n\n        //把学生添加到集合\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n\n        hs.add(s4);\n\n        //遍历集合\n        for (day6Student s : hs){\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n    }\n}\n\n\n```\n\n```python\npackage 集合框架.Set;\n\nimport java.util.Objects;\n\npublic class day6Student {\n    private String name;\n    private int age;\n\n    public day6Student(){\n\n    }\n    public day6Student(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        day6Student that = (day6Student) o;\n        return age == that.age && Objects.equals(name, that.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n\n```\n\n## LinkedHashSet集合特点\n\n\n\n```\n//1.哈希表和链表实现的Set接口，具有可预测的迭代次序\n//2.由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n//3.由哈希表保证元素唯一，也就是说没有重复的元素\n//\n//练习:存储字符串并遍历\n```\n\n```python\nimport java.util.LinkedHashSet;\n\npublic class day7LinkedHashSet集合概述和特点 {\n    public static void main(String[] args) {\n        //创建集合对象\n        LinkedHashSet<String> lsk = new LinkedHashSet<>();\n        //添加元素\n        lsk.add(\"hello\");\n        lsk.add(\"world\");\n        lsk.add(\"java\");\n        lsk.add(\"world\");\n        //遍历集合\n        for (String s : lsk){\n            System.out.println(s);\n        }\n    }\n}\n\n```\n\n## TreeSet集合概述和特点\n\n1.元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法\nTreeSet():根据其元素的自然顺序进行排序\nTreeSet(Comparator comparator):根据指定的比较器进行排序\n2.没有带索引的方法，所以不能使用普通for循环进行遍历\n3.由于是set集合，所以不包含重复元素的集合\n\n> ------\n> TreeSet集合练习:存储整数并遍历\n\n```python\nimport java.util.TreeSet;\n\npublic class day8TreeSet集合概述和特点 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<>(); //所有基本类型引用时需要用包装类\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n        //遍历\n        for (Integer i : ts){\n            System.out.println(i);\n        }\n    }\n}\n\n```\n\n## 自然排序Comparabale的使用\n\n存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n要求:按照年龄从小到大进行排序，年龄相同时，按照姓名的字母顺序排序\n\n```java\nimport java.util.TreeSet;\n\npublic class day9自然排序Comparabale的使用 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<day9Student> ts = new TreeSet<>();\n        //创建学生对象\n        day9Student s1 = new day9Student(\"xishi\",29);\n        day9Student s2 = new day9Student(\"wangzhaojun\",28);\n        day9Student s3 = new day9Student(\"diaochan\",30);\n        day9Student s4 = new day9Student(\"yangyuhuan\",33);\n        day9Student s5 = new day9Student(\"linqingxia\",33);\n        day9Student s6 = new day9Student(\"linqingxia\",33);\n        //把学生添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        //遍历集合\n        for (day9Student s : ts){\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n    }\n}\n\n```\n\n```java\npackage 集合框架.Set;\n\npublic class day9Student implements Comparable<day9Student>{\n    private String name;\n    private int age;\n\n    public day9Student(){\n\n    }\n    public day9Student(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(day9Student s) {\n//        return 0;\n//        return 1;\n//        return -1;\n        //按照年龄进行排序\n//        int num = s.age - this.age; 升序\n        int num = this.age - s.age;\n        int num2  = num==0?this.name.compareTo(s.name):num;\n        return num2;\n    }\n}\n\n```\n\n## 比较器排序Comparator的使用\n\n存储学生对象并遍历，创建TreeSet集合使用带参构造方法\n要求:按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n```java\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\npublic class day10比较器排序Comparator的使用 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<day10Student> ts = new TreeSet<>(new Comparator<day10Student>() {\n            @Override\n            public int compare(day10Student s1, day10Student s2) {\n                //this.age - s.age\n                //s1,s2\n                int num = s1.getAge()-s2.getAge();\n                int num2 = num==0?s1.getName().compareTo(s2.getName()):num;\n                return num2;\n            }\n        });\n        //创建学生对象\n        day10Student s1 = new day10Student(\"xishi\",29);\n        day10Student s2 = new day10Student(\"wangzhaojun\",28);\n        day10Student s3 = new day10Student(\"diaochan\",30);\n        day10Student s4 = new day10Student(\"yangyuhuan\",33);\n\n        day10Student s5 = new day10Student(\"linqingxia\",33);\n        day10Student s6 = new day10Student(\"linqingxia\",33);\n        //把学生添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        //遍历集合\n        for (day10Student s : ts){\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n    }\n}\n\n```\n\n```java\npackage 集合框架.Set;\n\npublic class day10Student {\n    private String name;\n    private int age;\n\n    public day10Student(){\n\n    }\n    public day10Student(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n```\n\n> 需求:用TreeSet集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合\n> 要求:按照总分从高到低出现\n\n\t思路:\n\t①定义学生类\n\t②创建TreeSet集合对象，通过比较器排序进行排序\n\t③创建学生对象\n\t④把学生对象添加到集合\n\t⑤遍历集合\n```java\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\npublic class day11案例成绩排序 {\n    public static void main(String[] args) {\n        //创建TreeSet集合对象，通过比较器排序进行排序\n        TreeSet<day11Student> ts = new TreeSet<>(new Comparator<day11Student>() {\n            @Override\n            public int compare(day11Student s1, day11Student s2) {\n                //int num = (s2.getChinese() + s2.getMath())-(s1.getChinese()-s2.getMath());\n                int num = s2.getSum()-s1.getSum();\n                int num2 = num==0?s1.getChinese()-s2.getChinese():num;\n                int num3 = num2==0?s1.getName().compareTo(s2.getName()):num2;\n                return num3;\n            }\n        });\n        //创建学生对象\n        day11Student s1 = new day11Student(\"林青霞\",98,100);\n        day11Student s2 = new day11Student(\"张曼玉\",95,95);\n        day11Student s3 = new day11Student(\"王祖贤\",100,93);\n        day11Student s4 = new day11Student(\"柳岩\",100,97);\n        day11Student s5 = new day11Student(\"风清扬\",98,98);\n        day11Student s6 = new day11Student(\"左冷禅\",97,99);\n        //day11Student s7 = new day11Student(\"左冷禅\",97,99);\n        day11Student s7 = new day11Student(\"赵云\",97,99);\n        //把学生添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        ts.add(s7);\n        //遍历集合\n        for (day11Student s: ts){\n            System.out.println(s.getName()+\",\"+s.getChinese()+\",\"+s.getMath()+\",\"+s.getSum());\n        }\n    }\n}\n\n```\n\n```java\npackage 集合框架.Set;\n\npublic class day11Student {\n    private String name;\n    private int chinese;\n    private int math;\n\n    public day11Student(){\n\n    }\n    public day11Student(String name,int chinese,int math){\n        this.name = name;\n        this.chinese = chinese;\n        this.math = math;\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n\n    public int getMath() {\n        return math;\n    }\n\n    public void setMath(int math) {\n        this.math = math;\n    }\n    public int getSum(){\n        return this.chinese+this.getMath();\n    }\n\n}\n\n```\n\n> 需求:编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出\n> ①创建set集合\n> ②创建随机数对象\n> ③判断集合的长度是不是小于10\n>  是:产生一个随机数，添加到集合\n>  回到3继续\n> ④遍历集合\n\n```java\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class day12案例不重复的随机数 {\n    public static void main(String[] args) {\n        //创建set集合\n        //Set<Integer> set = new HashSet<>(); 不会排序\n        Set<Integer> set = new TreeSet<>();  //会排序\n        //创建随机数对象\n        Random r = new Random();\n        //判断集合的长度是不是小于10\n        while (set.size()<10){\n            //产生一个随机数，添加到集合\n            int number = r.nextInt(20)+1;\n            set.add(number);\n        }\n        //遍历集合\n        for (Integer i : set){\n            System.out.println(i);\n        }\n    }\n}\n\n```\n\n# Map\n\n> Map集合概述:\n> ·Interface Map<K,V> K:键的类型;V:值的类型\n> ·将键映射到值的对象;不能包含重复的键;每个键可以映射最多一个值\n> ·举例:学生的姓名和学号\n> itheima001 林青霞\n> itheima002 张曼玉\n> itheima003 王祖贤\n>\n> 创建Map集合的对象 \n> ·多态的方式 \n> ·具体的实现类HashMap\n\n```java\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class day1Map集合概述和使用 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<>();\n        //添加元素\n        //V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。\n        map.put(\"itheima001\",\"林青霞\");\n        map.put(\"itheima002\",\"张曼玉\");\n        map.put(\"itheima003\",\"王祖贤\");\n        map.put(\"itheima003\",\"柳岩\");\n        //输出集合对象\n        System.out.println(map);\n    }\n}\n```\n\n```java\nV put(K key, V value) 添加元素\nV remove(Object key) 根据键删除值对元素\nvoid clear() 移除所有的键值对元素\nboolean containsKey(Object key) 判断集合是否包含指定的键\nboolean containsValue(Object value) 判断集合是否包含指定的值\nboolean isEmpty() 判断集合是否为空\nint size() 集合的长度也就是集合中键值对的个数\n```\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class day2Map集合的基本功能 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<>();\n        //V put(K key, V value) 添加元素\n        map.put(\"张无忌\",\"赵敏\");\n        map.put(\"郭靖\",\"黄蓉\");\n        map.put(\"杨过\",\"小龙女\");\n        //V remove(Object key) 根据键删除值对元素\n        System.out.println(map.remove(\"郭靖\"));\n        System.out.println(map.remove(\"郭想\"));\n        //void clear() 移除所有的键值对元素\n        //map.clear();\n        //boolean containsKey(Object key) 判断集合是否包含指定的键\n        System.out.println(map.containsKey(\"郭靖\"));\n        System.out.println(map.containsKey(\"张无忌\"));\n        //boolean isEmpty() 判断集合是否为空\n        System.out.println(map.isEmpty());\n        //int size() 集合的长度也就是集合中键值对的个数\n        System.out.println(map.size());\n        //输出集合对象\n        System.out.println(map);\n    }\n}\n\n```\n\n```java\nV get(Object key) 根据键获取值\nSet<k>keySet() 获取所有键的集合\nCollection<V>values() 获取所有值的集合\nSet<Map.Entry<K,V>>entrySet() 获取所有键值对对象的集合\n```\n\n```java\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class day3Map集合的获取功能 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<>();\n        //添加元素\n        map.put(\"张无忌\",\"赵敏\");\n        map.put(\"郭靖\",\"黄蓉\");\n        map.put(\"杨过\",\"小龙女\");\n        //V get(Object key) 根据键获取值s\n        System.out.println(map.get(\"张无忌\"));\n        System.out.println(map.get(\"张三丰\"));\n        //Set<k>keySet() 获取所有键的集合\n        Set<String> keySet = map.keySet();\n        for (String key: keySet){\n            System.out.println(key);\n        }\n        //Collection<V>values() 获取所有值的集合\n        Collection<String> values = map.values();\n        for (String value : values){\n            System.out.println(value);\n        }\n    }\n}\n\n```\n\n> 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n> 遍历思路\n> 1.把所有的丈夫集合起来\n> 2.遍历丈夫的集合，获取每一个丈夫\n> 3.根据丈夫去找对应的妻子\n>\n>  **转换为Map集合中的操作\n> 1.获取所有键的集合。用keySet()方法实现\n> 2.遍历键的集合，获取每一个键。用增强for实现\n> 3.根据键去找值。用get(Object key)方法实现**\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class day4Map集合的遍历1 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<>();\n        //添加元素\n        map.put(\"张无忌\",\"赵敏\");\n        map.put(\"郭靖\",\"黄蓉\");\n        map.put(\"杨过\",\"小龙女\");\n        //1.获取所有键的集合。用keySet()方法实现\n        Set<String> keySet = map.keySet();\n        //2.遍历键的集合，获取每一个键。用增强for实现\n        for (String key:keySet){\n            //3.根据键去找值。用get(Object key)方法实现\n            String value = map.get(key);\n            System.out.println(key+\",\"+value);\n        }\n    }\n}\n\n```\n\n```java\n//我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n//遍历思路\n//1.获得所有结婚证的集合\n//2.遍历结婚证的集合，得到每一个结婚证\n//3.根据结婚证获取丈夫和妻子\n\n//转换为Map集合中的操作:\n//获取所有键值对对象的集合\n//Set<Map.Entry<K,V>>entrySet():获取所有键值对对象的集合\n//遍历键值对对象的集合，得到每一个键值对对象\n//用增强for实现，得到每一个Map.Entry\n//根据键值对对象获取每一个键值对对象\n//用getKey()得到键\n//用getValue()得到值\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class day5Map集合的遍历2 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<>();\n        //添加元素\n        map.put(\"张无忌\",\"赵敏\");\n        map.put(\"郭靖\",\"黄蓉\");\n        map.put(\"杨过\",\"小龙女\");\n        //获取所有键值对对象的集合\n        Set<Map.Entry<String,String>> entrySet = map.entrySet();\n        //遍历键值对对象的集合，得到每一个键值对对象\n        for(Map.Entry<String,String> me : entrySet){\n            //根据键值对对象获取每一个键值对对象\n            String key = me.getKey();\n            String value = me.getValue();\n            System.out.println(key+\",\"+value);\n        }\n    }\n}\n\n```\n\n\n\n\n\n **需求:**\n 键盘录入一个字符串，要求统计字符串中每个字符出现的次数。\n\t举例:键盘录入 \"aababcabcdabcde\" 在控制台输出:\"a(5)b(4)c(3)d(2)e(1)\"\n\t\n**分析:**\n\t①我们可以把结果分成几个部分来看:a(5),b(4),c(3),d(2),e(1)\n\t②每一个部分可以看成是:字符和字符对应的次数组成\n\t③这样的数据，我们可以通过HashMap集合来存储，键是字符，值是字符出现的次数\n\t  注意:键是字符，类型应该是Character；值是字符出现的次数，类型应该是Integer\n\t\n**思路:**\n\t键盘录入一个字符串\n\t创建HashMap集合，键是Character，值是Integer\n\t遍历字符串，得到一个字符\n\t拿得到的每一个字符作为键到HashMap集合中去找对应的值，看起返回值\n\t  如果返回值是null：说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储\n\t  如果返回值不是null：说明该字符在集合中存在，把值加1，然后重新存储该字符和对应的值\n\t遍历HashMap集合，得到键和值，按照要求进行拼接\n\t输出结果\n```java\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeMap;\n\npublic class day10统计字符串中每个字符出现的次数 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        //创建HashMap集合，键是Character，值是Integer\n        //HashMap<Character,Integer> hm = new HashMap<Character,Integer>();\n        TreeMap<Character,Integer> hm = new TreeMap<Character,Integer>();\n        //遍历字符串，得到一个字符\n        for (int i = 0; i < line.length() ;i++) {\n            char key = line.charAt(i);\n            //拿得到的每一个字符作为键到HashMap集合中去找对应的值，看起返回值\n            Integer value = hm.get(key);\n            if (value == null){\n                //  如果返回值是null：说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储\n                hm.put(key,1);\n            }else{\n                //  如果返回值不是null：说明该字符在集合中存在，把值加1，然后重新存储该字符和对应的值\n                value++;\n                hm.put(key,value);\n            }\n        }\n        //遍历HashMap集合，得到键和值，按照要求进行拼接\n        StringBuilder sb = new StringBuilder();\n        Set<Character> keySet = hm.keySet();\n        for (Character key : keySet){\n            Integer value = hm.get(key);\n            sb.append(key).append(\"(\").append(value).append(\")\");\n        }\n        String result = sb.toString();\n        //输出结果\n        System.out.println(result);\n    }\n}\n\n```\n\n# Collections\n\n> Collections类的常用方法\n> ·public static <T extends Comparable <?super T>> void sort(List<T> list):将指定的列表按升序排序\n> ·public static void reverse(List <?>list):反转指定列表中元素的顺序\n> ·public static void shuffle(List<?> list):使用默认的随机源随机排列指定的列表\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class day1Collections概述和使用 {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<Integer> list = new ArrayList<>();\n        //添加元素\n        list.add(30);\n        list.add(20);\n        list.add(50);\n        list.add(10);\n        list.add(40);\n        //·public static <T extends Comparable <?super T>> void sort(List<T> list):将指定的列表按升序排序\n        Collections.sort(list);\n        //·public static void reverse(List <?>list):反转指定列表中元素的顺序\n        Collections.reverse(list);\n        //·public static void shuffle(List<?> list):使用默认的随机源随机排列指定的列表\n        Collections.shuffle(list);\n        System.out.println(list);\n    }\n}\n```\n**需求**:ArrayList存储学生对象，使用Collections对ArrayList进行排序\n**要求**:按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序进行排序\n\n**思路:**\n①定义学生类\n②创建ArrayList集合对象\n③创建学生对象\n④把学生添加到集合\n⑤使用Collections对ArrayList集合排序\n⑥遍历集合\n\n```java\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\npublic class day2ArrayList集合存储学生并排序 {\n    public static void main(String[] args) {\n        //创建ArrayList集合对象\n        ArrayList<day2Student> array = new ArrayList<>();\n        //创建学生对象\n        day2Student s1 = new day2Student(\"linqingxia\",30);\n        day2Student s2 = new day2Student(\"zhangmanyu\",35);\n        day2Student s3 = new day2Student(\"wangzuxian\",33);\n        day2Student s4 = new day2Student(\"liuyan\",33);\n        //把学生添加到集合\n        array.add(s1);\n        array.add(s2);\n        array.add(s3);\n        array.add(s4);\n        //使用Collections对ArrayList集合排序\n        Collections.sort(array, new Comparator<day2Student>() {\n            @Override\n            public int compare(day2Student s1, day2Student s2) {\n                int num = s1.getAge() - s2.getAge();\n                int num2 = num==0?s1.getName().compareTo(s2.getName()):num;\n                return num2;\n            }\n        });\n        //遍历集合\n        for (day2Student s : array){\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n    }\n}\n\n```\n","tags":["Java","Java集合框架"],"categories":["Java"]},{"title":"Java多线程","url":"/2021/12/19/Java多线程/","content":"\n@[toc]\n# 实现多线程\n## 进程和线程\n\n**进程:** 是正在运行的程序\n\n> ·是系统进行资源分配和调用的独立单位\n\n> ·每一进程都有它自己的内存空间和系统资源\n\n**线程:**\n\n>  是进程中的单个顺序控制流，是一条执行路径\n\n> 单线程:一个进程如果只有一条执行路径，则成为单线程程序\n\n> 多线程:一个进程如果有多条执行路径，则成为多线程程序\n\n**举例:**\n\n> (单线程)记事本程序，(多线程)扫雷游戏\n\n## 多线程的实现方式\n\n\t定义一个类MyThread继承Thread类\n\t在MyThread类中重写run()方法\n\t创建MyThread类的对象\n\t启动线程\n\n**两个小问题:**\n\n```为什么要重写run()方法呢？```\n\n\n>    因为run()是用来封装被线程执行的代码\n\n```run()方法和start()方法的区别```\n\n\n>  run():封装线程执行的代码,直接调用,相当于普通方法的调用\n\n> start():启动线程；然后由jvm调用此线程的run()方法\n\n```java\npublic class day2继承Thread类的方式实现多线程 {\n    public static void main(String[] args) {\n        day2MyThread my1 = new day2MyThread();\n        day2MyThread my2 = new day2MyThread();\n\n        //my1.run();\n        //my2.run();\n\n        //void start() 导致此线程开始执行；Java虚拟机调用此线程的run方法\n        my1.start();\n        my2.start();\n    }\n}\n\n```\n\n## 设置和获取线程名称\n\n**Thread类中设置和获取线程名称的方法**\n·void setName(String name): 将此线程的名称更改为等于参数name\n·String getName():返回此线程的名称\n·通过构造方法也可以设置线程名称\n\n**如何获取main()方法所在的线程名称？**\n·public static Thread currentThread():返回对当前正在执行的线程对象的引用\n\n```java\npublic class day3设置和获取线程名称 {\n    public static void main(String[] args) {\n//        day3MyThread my1 = new day3MyThread();\n//        day3MyThread my2 = new day3MyThread();\n//        //void setName(String name): 将此线程的名称更改为等于参数\n//        my1.setName(\"高铁\");\n//        my1.setName(\"飞机\");\n\n        //Thread(String name)\n        day3MyThread my1 = new day3MyThread(\"飞机\");\n        day3MyThread my2 = new day3MyThread(\"高铁\");\n\n        my1.start();\n        my2.start();\n\n        //static Thread currThread() 返回对当前正在执行的线程对象的引用\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\n```\n\n```java\npublic class day3MyThread extends Thread {\n    public day3MyThread(){\n\n    }\n    public  day3MyThread(String name){\n        super(name);\n    }\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName()+\":\"+i);\n        }\n    }\n}\n```\n\n## 线程调度\n\n**线程有两种调度模型:**\n\n> ·分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片\n\n> ·抢占式调度模型:优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一点\n> Java使用的是抢占式调度模型\n\n*假设计算机只有一个CPU，那么CPU在某一时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。\n所以说多线程程序的执行是随机性，因为谁抢到CPU的使用权是不一定的*\n\n**Thread类中设置和获取线程优先级的方法:**\n\n```java\n public final void setPriority(int newPriority):更改此线程的优先级\n```\n\n```java\n public final int getPriority():返回此线程的优先级\n```\n\n**线程默认优先级是5；线程优先级的范围是：1-10**\n**线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果**\n\n```java\npublic class day4线程调度 {\n    public static void main(String[] args) {\n        day4MyThread tp1 = new day4MyThread();\n        day4MyThread tp2 = new day4MyThread();\n        day4MyThread tp3 = new day4MyThread();\n\n        tp1.setName(\"高铁\");\n        tp2.setName(\"飞机\");\n        tp3.setName(\"汽车\");\n\n        //public final int getPriority():返回此线程的优先级\n//        System.out.println(tp1.getPriority());//5\n//        System.out.println(tp2.getPriority());//5\n//        System.out.println(tp3.getPriority());//5\n\n// public final void setPriority(int newPriority):更改此线程的优先级\n//        tp1.setPriority(10000);//IllegalArgumentException\n//        System.out.println(Thread.MAX_PRIORITY);\n//        System.out.println(Thread.MIN_PRIORITY);\n//        System.out.println(Thread.NORM_PRIORITY);\n\n        //设置正确的优先级\n        tp1.setPriority(5);\n        tp2.setPriority(10);\n        tp3.setPriority(1);\n\n        tp1.start();\n        tp2.start();\n        tp3.start();\n    }\n}\n\n```\n\n## 线程生命周期\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/891828b4566b444096c38b8695490011.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n```java\npublic class day6线程生命周期 {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(()->{\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"//////\");\n        });\n        //观察状态\n        Thread.State state = thread.getState();\n        System.out.println(state); //new\n        //观察启动后\n        thread.start();//启动线程\n        state = thread.getState();\n        System.out.println(state);//Run\n        while (state != Thread.State.TERMINATED) {//只要线程不终止，就一直输出状态\n            Thread.sleep(100);\n            state = thread.getState();//更新线程状态\n            System.out.println(state);//输出状态\n        }\n    }\n}\n\n```\n\n## 多线程的实现方式2\n\n**方式2:实现Runnable接口**\n\n·定义一个类MyRunnable实现Runnable接口\n\n·在MyRunnable中重写run()方法\n\n·创建MyRunnable类对象\n\n·创建Thread类的对象,把MyRunnable对象作为构造方法的参数\n\n·启动线程\n\n**多线程的实现有两种:**\n\n·继承Thread类\n\n·实现Runnable接口\n\n**相比继承Thread类，实现Runnable接口的好处:**\n\n·避免了Java单继承的局限性\n\n·适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现了面向对象的设计思想\n\n```java\npublic class day7多线程的实现方式 {\n    public static void main(String[] args) {\n        //·创建MyRunnable类对象\n        day7MyRunnable my = new day7MyRunnable();\n        //把MyRunnable对象作为构造方法的参数\n        //Thread(Runnable target)\n//        Thread t1 = new Thread(my);\n//        Thread t2 = new Thread(my);\n        Thread t1 = new Thread(my,\"高铁\");\n        Thread t2 = new Thread(my,\"飞机\");\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n```java\npublic class day7MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);//这里不能直接使用getName方式\n        }\n    }\n}\n\n```\n# 线程同步\n\n## 共享数据安全问题\n\n**为什么出现问题?(这也是我们判断多线程程序是否会有数据安全问题的标准)**\n\n·是否是多线程环境\n·是否有共享数据\n·是否有多条语句操作共享数据\n\n**如何解决多线程安全问题呢？**\n\n·基本思想:让程序没有安全问题的环境\n\n**怎么实现呢?**\n\n把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n**同步代码块：**\n\n锁多条语句操作共享数据的代码，可以使用同步代码块实现\n·格式:\nsynchronized(任意对象){\n 多条语句操作共享数据的代码\n }\n·synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n**同步的好处和弊端**\n\n·好处：解决了多线程的数据安全问题\n·弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n```java\npublic class day3卖票案例数据安全问题的解决 {\n    public static void main(String[] args) {\n        //  A:创建SellTicket对象\n        day3SellTickets st = new day3SellTickets();\n        //  B:创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n        Thread t1 = new Thread(st,\"窗口一\");\n        Thread t2 = new Thread(st,\"窗口二\");\n        Thread t3 = new Thread(st,\"窗口三\");\n        //  C:启动线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\n```\n\n```java\npublic class day3SellTickets implements Runnable{\n    private int tickets = 100;\n    private Object obj = new Object();\n    @Override\n    public void run() {\n        while (true){\n            synchronized (obj) {\n                if (tickets > 0) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                    tickets--;\n                }\n            }\n        }\n    }\n}\n\n```\n\n## 同步方法\n\n**同步方法:** 就是把synchronized关键字加到方法上\n\n**·格式:**\n\n修饰符synchronized返回值类型 方法名(方法参数){ }\n\n**同步方法的锁对象是什么呢：**\n\n·是this这个对象\n\n**同步静态方法:** 就是把synchronized关键字加到静态方法上\n\n**·格式:**\n\n修饰符 static synchronized 返回值类型 方法名(方法参数){ }\n\n```java\npublic class day4同步方法 {\n    public static void main(String[] args) {\n        day4SellTickets st = new day4SellTickets();\n\n        Thread t1 = new Thread(st,\"窗口1\");\n        Thread t2 = new Thread(st,\"窗口2\");\n        Thread t3 = new Thread(st,\"窗口3\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n\n\n    }\n}\n```\n\n```java\npackage 多线程.线程同步;\n\npublic class day4SellTickets implements Runnable{\n//    private int tickets = 100;\n    private static int tickets = 100;\n    private Object obj = new Object();\n    private int x = 0;\n    @Override\n    public void run() {\n        while(true){\n            if (x%2==0) {\n                //synchronized (obj) {\n//                synchronized (this) {\n                synchronized (day4SellTickets.class) {\n                    if (tickets > 0) {\n                        try {\n                            Thread.sleep(100);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                        tickets--;\n                    }\n                }\n            }else{\n//                synchronized (obj) {\n//                    if (tickets > 0) {\n//                        try {\n//                            Thread.sleep(100);\n//                        } catch (InterruptedException e) {\n//                            e.printStackTrace();\n//                        }\n//                        System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n//                        tickets--;\n//                    }\n//                }\n                sellTicket();\n            }\n            x++;\n        }\n    }\n\n//    private void sellTicket() {\n//        synchronized (obj) {\n//            if (tickets > 0) {\n//                try {\n//                    Thread.sleep(100);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//                System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n//                tickets--;\n//            }\n//        }\n//private synchronized void sellTicket() {\n//\n//        if (tickets > 0) {\n//            try {\n//                Thread.sleep(100);\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//            System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n//            tickets--;\n//        }\n//    }\nprivate static synchronized void sellTicket() {\n\n    if (tickets > 0) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n        tickets--;\n    }\n    }\n}\n\n```\n\n## 线程安全的类\n\n**StringBuffer**\n\n·线程安全,可变的字符序列\n·从版本JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类。因为它支持所有相同的操作，但它更快，因为它不执行同步\n\n**Vector**\n\n·从Java2平台v1.2开始，该类改进了List接口，使其成为Java Collections Framework的成员。与新的集合实现不同，Vector被同步。\n如果不需要线程安全的实现，建议使用ArrayList代替Vector\n\n**Hashtable**\n\n·该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值\n·从Java2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成员。\n与新的集合实现不同，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashtable\n\n```java\nimport java.io.StringBufferInputStream;\nimport java.util.*;\n\npublic class day5线程安全的类 {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer();\n        StringBuilder sb2 = new StringBuilder();\n\n        Vector<String> v = new Vector<>();\n        ArrayList<String> array = new ArrayList<>();\n\n        Hashtable ht = new Hashtable();\n        HashMap<String,String> hm = new HashMap();\n\n        //static <T> List<T> synchronizedList(List<T> list) 返回由指定列表支持的同步（线程安全）列表。\n        Collections.synchronizedList(new ArrayList<>());\n    }\n}\n\n```\n\n## Lock锁\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们没有直接看到在哪里加上了锁，在哪里释放了锁，\n为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作\nLock中提供了获得锁和释放锁的方法\n\n```java\n·void lock():获得锁\n```\n\n```java\n·void unlock():释放锁\n```\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\nReentrantLock的构造方法\n·ReentrantLock():创建一个ReentrantLock的实例\n\n```java\npublic class day6Lock锁 {\n    public static void main(String[] args) {\n        day6SellTickets st = new day6SellTickets();\n\n        Thread t1 = new Thread(st,\"窗口1\");\n        Thread t2 = new Thread(st,\"窗口2\");\n        Thread t3 = new Thread(st,\"窗口3\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class day6SellTickets implements Runnable{\n    private int tickets = 100;\n    private Lock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        while (true){\n            try{\n                lock.lock();\n                if (tickets > 0) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                    tickets--;\n                }\n            }finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n```\n\n## 生产者消费者案例\n\n**生产者消费者案例中包含的类:**\n\n奶箱类(Box):定义一个成员变量，表示第X瓶奶，提供存储牛奶和获取牛奶的操作\n\n生产者类(Producer):实现Runnable接口，重写run()方法，调用存储牛奶的操作\n\n消费者类(Customer):实现Runnable接口，重写run()方法，调用获取牛奶的操作\n\n测试类(BoxDemo):这里面有main方法，main方法中的代码步骤如下\n\n  ①创建奶箱对象，这是共享数据区域\n\n  ②创建生产者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用存储牛奶的操作\n\n  ③创建消费者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用获取牛奶的操作\n\n  ④创建2个线程对象，分别把生产者和消费者对象作为构造方法参数传递\n\n  ⑤启动线程\n\n```java\n//奶箱类(Box):定义一个成员变量，表示第X瓶奶，提供存储牛奶和获取牛奶的操作\n\npublic class Box {\n    //定义一个成员变量，表示第X瓶奶\n    private int milk;\n    //定义一个成员对象，表示奶箱的状态\n    private boolean state = false;\n    //提供存储牛奶和获取牛奶的操作\n    public synchronized void put(int milk){\n        //如果有牛奶，等待消费\n        if (state){\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //如果没有牛奶，生产牛奶\n        this.milk = milk;\n        System.out.println(\"送奶工将第\"+this.milk+\"瓶奶放入奶箱\");\n\n        //生产完毕之后，修改奶箱状态\n        state = true;\n        //唤醒其他等待的线程\n        notifyAll();\n    }\n    public synchronized void get(){\n        //如果没有牛奶，等待生产\n        if (!state){\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //如果有牛奶，就消费牛奶\n        System.out.println(\"用户拿到了第\"+this.milk+\"瓶奶\");\n        //消费完毕之后，修改奶箱状态\n        state = false;\n        //唤醒其他等待的线程\n        notifyAll();\n    }\n}\n\n```\n\n```java\n//测试类(BoxDemo):这里面有main方法，main方法中的代码步骤如下4\n//  ①创建奶箱对象，这是共享数据区域\n//  ②创建生产者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用存储牛奶的操作\n//  ③创建消费者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用获取牛奶的操作\n//  ④创建2个线程对象，分别把生产者和消费者对象作为构造方法参数传递\n//  ⑤启动线程\n\n\npublic class BoxDemo {\n    public static void main(String[] args) {\n        //①创建奶箱对象，这是共享数据区域\n        Box b = new Box();\n        //②创建生产者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用存储牛奶的操作\n        Producer p = new Producer(b);\n        //③创建消费者对象，把奶箱对象作为构造方法参数传递，因为这个类中要调用获取牛奶的操作\n        Customer c = new Customer(b);\n        //④创建2个线程对象，分别把生产者和消费者对象作为构造方法参数传递\n        Thread t1 = new Thread(p);\n        Thread t2 = new Thread(c);\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n```java\npublic class Customer implements Runnable{\n    private Box b;\n    public Customer(Box b) {\n        this.b = b;\n    }\n\n    @Override\n    public void run() {\n        while(true){\n            b.get();\n        }\n    }\n}\n\n```\n\n```java\n//生产者类(Producer):实现Runnable接口，重写run()方法，调用存储牛奶的操作\n\npublic class Producer implements Runnable {\n    private Box b;\n    public Producer(Box b) {\n        this.b = b;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i <= 30; i++) {\n            b.put(i);\n        }\n    }\n}\n```\n","tags":["Java多线程"],"categories":["Java"]},{"title":"Java集合框架面试题（更新中）","url":"/2021/12/19/Java集合框架面试题总结（更新中）/","content":"\n##     说出 collection 的常用子接口？说出 3 个以上的常 用方法？都有什么作用？\n\n**1. Collection具有两个比较常用的子接口，List和Set;**\n**2. Collection中的常用方法**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a896ef40e1e14042a6af1bfa4b279fd4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n1、添加\n\nBoolean add(E e):在集合中添加一个对象，如果添加成功，返回true，如果失败，返回false\n\nBoolean addAll(Collection<?extend E> e)：在集合中添加另一个集合，成功true,失败false;\n\n2、删除\nBoolean remove(object obj):删除一个对象,会改变集合的长度\n\nBoolean removeAll(Colleciton con);删除一个集合，还有两个集合中相同的元素\n\nvoid clear():删除所有\n\n3、判断\nBoolean contains(object obj):在集合中是否包含指定的对象\n\nBoolean containsAll(Collection con):在集合是否包含另一个集合\n\nBoolean isEmpty( )：判断集合是否为空\n\n4、获取\n\nint size( )：得到集合的尺寸大小      数组:length   字符串:length( );\n\nIterator iterator( )：取出元素的方式。迭代器。该对象必须依赖于绝缘体容器，因为每一个容器的数据结构都不同。所以该迭代器对象是在容器中进行内部实现的，对于使用容器者而言，绝缘体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法，Iterator接口就是对所有的collection容器进行元素取出的公共接口。将每一个容器中的取出方式进行了封装，并对外暴露，这样无论是什么容器或者数据结构，只要内部取出方式实现了Iterator接口，都可以通过该接口取出这些容器中的元素。他的出现，将容器的取出方式和容器的数据结构相分离，降低了耦合性，而取出方式因为直接在访问容器的元素，并依赖具体的数据结构，所以被定义在了容器中。通过内部类来实现Iterator接口。\n\n```java\nCollection c = new ArrayList();\n\nc.add(\"hello\");\n\nIteratot it = c.iterator();//返回的是Iterator的子类对象\n\nwhile(it.hasNext()){\n\nString str = (String)it.next();\n\nSystem.out.println(str);\n\n}\n```\n\n \n\nfor(object obj:con)用于数组和集合(高级for循环)\n\n注意：迭代要强转，只能有一个next( )方法，否则会有NoSuchElementException异常。\n\n5、交集\n\nboolean retainAll(Collection c)：返回两个集合的交集元素，删除其他元素，功能和removeAll相反。有A,B两个集合，做完交集后，A集合中的元素发生变化，取得是A和B相同的元素，B不变化。boolean值的问题-------->只要A集合变化,那么返回true.否则false\n\n  \n\n6、集合转数组\n\nObject[ ] toArray()：把集合转换成对象。\n\n## 如果向 TreeSet 中加入类对象，需要做什么？\n实现Comparable接口重写compareTo方法或者在TreesSet创建对象时传入自定义的比较类\n\n## Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是 equals()? 它们有何区别?\n从它俩的区别谈起，==是用来判断两者是否是同一对象（同一事物），而equals是用来判断是否引用同一个对象。再看一下Set里面存的是\n\n对象，还是对象的引用。根据java的存储机制可知，set里面存放的是对象的引用，所以当两个元素只要满足了equals()时就已经指向同一个对象，\n\n也就出现了重复元素。所以应该用equals()来判断。\n\n## ArrayList 和 Vector 的区别？\n1.ArrayList是线程不安全的，Vector是线程安全的\n2.ArrayList扩容是原来一半，Vector是原来的一倍\n\n## 集合当中能存放基本数据类型的数据吗？\nJava集合不能存放基本数据类型，只能存放对象的引用。\n\n每个集合元素都是一个引用变量，实际内容都存放在堆内或方法区里面，\n\n但是基本数据类型是在栈内存上分配空间的，栈上的数据随时会被收回。\n\n如何解决？\n\n可以通过包装类，把基本数据类型转化为对象类型，存放引用。\n\n更方便的，由于有了自动拆箱和装箱功能，基本数据类型和其对应对象\n\n之间的转换变得很方便，把基本数据类型存入集合中可以自动存，系统\n\n会自动将其装箱成封装类，然后将其加入到集合当中。\n\n## ArrayList 与数组的区别?\nArray可以包含基本类型和对象类型，ArrayList只能包含对象类型。\n\nArray大小是固定的，ArrayList的大小是动态变化的。\n\n## java 集合框架的四种主要接口是\nCollection：存储无序的、不唯一的数据；其下有List和Set两大接口。\n\nList：存储有序的、不唯一的数据；\n\nSet：存储无序的、唯一的数据；\n\nMap：以键值对的形式存储数据，以键取值。键不能重复，但值可以重复。\n\n## HashMap 和 Hashtable 的区别?\n1 HashMap不是线程安全的\n\nHashMap是map接口的子类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。\n\n2   HashTable是线程安全。\n\nHashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。\n\nHashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差\n\n## Collection 框架中实现比较方法\nJava集合框架中需要比较大小的集合包括TreeMap、TreeSet，其中TreeMap会根据key-value对中key的大小进行排序，而TreeSet则会对集合元素进行排序。\n因此TreeMap的key、TreeSet的集合元素，都需要可以比较大小。集合框架中之比较大小的有两种方式：\n\nA．自然排序：对于自然排序来说，要求TreeMap中的所有key都实现Comparable接口，实现该接口时需要实现一个int compareTo(T o)方法，用于判断当前对象与o对象之间的大小关系。如果该方法返回正整数，则说明当前对象大于o对象；如果该方法返回0，说明两个对象相等；如果该方法返回负整数，则说明当前对象小于o对象；JDK的很多类都已经实现了Comparable接口，例如String、Date、BigDecimal等。\n\nB．定制排序：定制排序需要在创建TreeMap或TreeSet时传入一个Comparator对象，此时TreeMap或TreeSet不再要求key、集合元素本身是可比较大小的，而是由Comparator来负责比较集合元素的大小。Comparator本身只是一个接口，因此创建Comparator对象只能是创建它的实现类的对象，Comparator的实现类需要实现int compare(T o1, T o2)方法，该方法用于判断o1、o2两个对象的大小，如果该方法返回正整数，则说明o1大于o2、如果该方法返回负整数，则说明o1小于o2、如果返回0，则说明两个对象相等。\n\n## 在 Java 中，HashMap 中是用哪些方法来解决哈希冲突的？\n**解决哈希冲突的方法有三种,分别是:**\n\n```开放地址法```:寻找下一个为空的数组下标,而后将冲突元素存储\n```再散列法(二次哈希法)```:再次使用一个不同的哈希算法再计算一次 (第一次%16换另一个数进行%运算)\n```链地址法(拉链法)```:将所有冲突元素按照链表存储,冲突后时间复杂度变为O(1+n)n为冲突元素个数)[hashMap就是用这种方法]\n\n**首先来了解一下什么是哈希表**\n\n哈希表是以(Key,Value):数值的形式存储数据的\n\n根据相应的哈希算法计算key,返回值即为V存储的数组下标\n\n哈希算法:f(K) --- . int即为V需要存储的数组下标\n\n**为什么会造成哈希冲突呢?**\n\n用一个数去模运算,取得余数就是所要存储数组数据的下标,但是余数可能会存在一样的,这样就导致一样余数的户数无处存储,所以就造成了哈希冲突.\n\n**哈希冲突解决思路:**\n\n哈希算法计算的两个不同对象的哈希值相等的情况\n\n> eg:1 % 16 == 17 % 16[1和17是不同的key值]--->就是哈希冲突了\n\nHashMap中用链地址法来解决 \n\nHashMap源码解析(负载因子,树化策略,内部hash实现,resize策略...)\nHashMap中的内部属性:\n\n负载因子:final loadFactor (默认为0.75f)\n实际容量: int threshold = loadFactor * tab.length\n树化阈值:int TREEIFY_THRESHOLD = 8;\n解除树化阈值: int UNTREEIFY_THRESHOLD = 6;\nHashMap也采用了懒加载策略,第一次put时初始化哈希表\n树化逻辑:索引下标对应的链表长度达到阈值8并且当前哈希表长度达到64才不会树化,否则只是调用resize()方法进行哈希表扩容\nresize();扩容为原先数组的2倍\n负载因子大小怎么决定?\n\n负载因子过大会导致哈希冲突明显增加,节省内存\n\n负载因子过小会导致哈希表频繁扩容,内存利用率低\n\n 默认0.75,0.75是一个经过计算得出的值,即能保证哈希冲突不会太严重也能保证效率不会太低\n\n源码: \n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n \nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n可以发现源码中并没有直接使用Object中的hashCode方法,而是再让h无符号右移了16位\n\n为何不直接使用Object提供的hashCode?\n\n为了将哈希码保留一半,将高低位都参与运算,减少内存开销,减少哈希冲突\n\n直接使用会造成空间浪费\n\n(h = key.hashCode()) ^ (h >>> 16); //32 --->16 保留一半(原本32右移16位去掉了一半)\n\nput内部逻辑:\n\n\n1.哈希表索引下标计算:\n\ni = (n-1) & hash   //与运算\n\n保证求出的索引下标都在哈希表的长度范围之内\n\n2.n为哈希表的长度\n\nn必须为2 的n次方,保证哈希表中的所有索引下标都会被访问到\n\n若n=15,则以下位置永远不可能存储元素\n\n0011,0101,1001,1011,1101,1111\n\n接下来再看源码:\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n//第一次put值的时候将哈希表初始化\n//resize():1,完成哈希表的初始化  2.完成哈希表的扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n//当目标索引未存储元素时,将当前元素存储到目标索引位置\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n//哈希表已经初始化并且算出的数据下标已经有元素了\n    else {\n        Node<K,V> e; K k;\n//若索引下标对应的元素key值恰好与当前元素key值相等且不为空,\n//将value替换为当前元素的value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n//此时索引对应的链表已经树化了,采用红黑树方式将当前节点添加到树中\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n//以链表方式将当前节点添加到链表末尾\n        else {\n            for (int binCount = 0; ; ++binCount) { //binCount当前链表的长度\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //尝试将链表树化\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n//扩容策略\n//此时添加了新节点\n    if (++size > threshold)\n        //扩容\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n## 为何HashMap中JDK1.8要引入红黑树?\n\n当链表长度过长时,会将哈希表查找的时间复杂度退化为O(n),树化会保证即便在哈希冲突严重时,查找的时间复杂度也为O(logn)\n\n当红黑树结点个数在扩容或者删除元素时减少为6以下,在下次resize()过程中会将红黑树退化为链表,节省空间\n\n## Collection 和 Collections 的区别?\n1、Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。\n2、Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\n","tags":["Java","集合框架"],"categories":["Java"]},{"title":"Java网络编程","url":"/2021/12/19/Java网络编程/","content":"\n# 网络编程概述\n\n## 计算机网络\n\n·是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，\n 在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n## 网络编程\n\n·在通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换\n\n# 网络编程三要素\n\n## IP地址\n\n·要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定\n 要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n## 端口\n\n·网络的通信，本质是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，\n如何区分这些应用程序呢？如果说IP地址可以唯一识别网络中的设备，那么端口号就可以唯一标识\n 设备中的应用程序了。也就是应用程序的标识。\n\n\n\n## 协议:\n\n·通过计算机网络可以使多台计算机实现连接，位于同一网络中的计算机在进行连接和通信时需要遵守一定的规则，\n 这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议\n 它对数据的传输格式，传输速率，传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。\n 常见的协议有UDP协议和TCP协议\n\n# IP地址\n\n是网络中设备的唯一标识\n\n## IP地址分类两大类:\n\nIPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit\n 也就是4个字节。例如一个采用二进制形式的IP地址是\"11000000 10101000 00000001 01000010\",这么长的地址，处理\n 起来也太费劲了。为了方便使用，IP地址通常被写成十进制的形式，中间使用符号\".\"分隔不同的字节\n 于是，上面的IP地址可以表示为\"192.168.1.66\"。IP地址的这种表示法叫做\"点分十进制表示法\"，这显然比1和0容易记忆得多\n\nIPv6：由于互联网的蓬勃发展，IP地址的需求量越来越大，但是网络地址资源有限，使得IP的分配越发紧张。\n 为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16字节一组，分成8组十六进制数，这样就解决了网络\n 地址资源数量不够的问题\n\nIP地址\n\n## 常用命令:\n\nipconfig:查看本机IP地址\nping IP地址:检查网络是否联通\n\n## 特殊IP地址:\n\n127.0.0.1：是回送地址，可以代表本机地址，一般来测试使用\n\n# InetAddress的使用\n\n为了方便我们对IP地址的获取和操作，Java提供了一个类InetAddress供我们使用\n\nInetAddress:此类表示Internet协议(IP)地址\n\n               方法名                            说明\n\n>  static InetAddress getByName(String host)   \n>  确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址\n\n>  String getHostName()                         获取此IP地址的主机名\n\n>  String getHostAddress()                      返回文本显示的IP地址字符串\n\n```java\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class day4InetAddress的使用 {\n    public static void main(String[] args) throws UnknownHostException {\n        //static InetAddress getByName(String host)    确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址\n        InetAddress address = InetAddress.getByName(\"192.168.1.101\");\n        // String getHostName()]获取此IP地址的主机名\n        String name = address.getHostName();\n        // String getHostAddress() 返回文本显示的IP地址字符串\n        String ip = address.getHostAddress();\n        System.out.println(\"主机名：\"+name);\n        System.out.println(\"ip地址: \"+ip);\n    }\n}\n```\n\n# 端口\n\n设备上应用程序的唯一标识\n\n端口号:用两个字节表示的整数，它的取值范围是0-65535,。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n# 协议\n\n> 协议:计算机网络中，连接和通信的规则被称为网络通信协议\n\n## UDP协议:\n\n**·用户数据报协议(User Datagram Protocol)**\n·UDP是无连接通讯协议，即在数据传输时，数据的发送端和接收端不建立逻辑联系。简单来说，当一台\n 计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时\n 也不会向发送端反馈是否收到数据\n  由于使用UDP协议消耗资源少，通信效率高，所以通常都会用于音频，视频和普通数据的传输\n·例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生\n 太大影响。但是在使用UDP协议传输数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议\n 使用UDP协议\n\n## TCP协议\n\n**·传输协议(Transmission Control Protocol)**\n·TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑相连，然后再传输数据，\n 它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向\n 服务器端发出连接请求，每次连接的创建都需要经过\"三次握手\"\n\n### ·三次握手\n\n:TCP协议中，在发送数据的准备阶段，客户端和服务器之间的三次交互，以保证连接的可靠\n 第一次握手:客户端向服务器端发出连接请求，等待服务期确认\n 第二次握手:服务器端向客户端回送一个响应，通知客户端收到了连接请求\n 第三次握手:客户端再次向服务器端发送确认信息，确认连接\n\n完成三次握手，连接了建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的\n 的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件，下载文件，浏览网页等。\n\n# UDP通信原理\n\n\nUDP协议是一种不可靠的网络协议，它在通信端各建立一个Socket对象，但是这两个Socket只是发送，接受数据的对象\n\n因此基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\nJava提供了DatagramSocket类作为基于UDP协议的Socket\n\n## UDP发送数据\n\n### 发送数据的步骤\n\n①创建发送端的Socket对象(DatagramSocket)\n②创建数据，并把数据打包\n③调用DatagramSocket对象的方法发送数据\n④关闭发送端\n\n```java\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class day1UDP发送数据 {\n    public static void main(String[] args) throws IOException {\n        //①创建发送端的Socket对象(DatagramSocket)\n        //DatagramSocket()\n        //构建一个数据报套接字绑定到本地主机的任何可用的端口。\n        DatagramSocket ds = new DatagramSocket();\n        //②创建数据，并把数据打包\n        //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n        //指定主机上的指定端口发送数据包的长度 length数据报包结构。\n        byte[] bys = \"hello,udp,我来了\".getBytes();\n//        int length = bys.length;\n//        InetAddress address = InetAddress.getByName(\"192.168.1.66\");\n//        int port = 10086;\n        DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(\"192.168.1.66\"),10086);\n        //③调用DatagramSocket对象的方法发送数据\n        //public void send(DatagramPacket p) 从这个套接字发送数据报包。\n        ds.send(dp);\n        //④关闭发送端\n        ds.close();//close() 关闭该数据报套接字。\n    }\n}\n\n```\n\n## UDP接收数据\n\n### 接收数据的步骤\n\n①创建接收端的Socket对象(DatagramSocket)\n②创建一个数据包，用于接收数据\n③调用DatagramSocket对象的方法接收数据\n④解析数据包，并把数据在控制台显示\n⑤关闭接收端\n\n先接收，后发送\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class day2UDP接收数据 {\n    public static void main(String[] args) throws IOException {\n        //①创建接收端的Socket对象(DatagramSocket)\n        //DatagramSocket(int port)\n        //构建一个数据报套接字绑定到本地主机的指定端口。\n        DatagramSocket ds = new DatagramSocket(10086);\n        //②创建一个数据包，用于接收数据\n        //DatagramPacket(byte[] buf, int length)\n        //接收数据包长度 length DatagramPacket构建。\n        byte[] bys = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(bys,bys.length);\n        //③调用DatagramSocket对象的方法接收数据\n        ds.receive(dp);\n        //④解析数据包，并把数据在控制台显示\n        //getData()\n        //返回数据缓冲区。\n        byte[] datas = dp.getData();\n        int len = dp.getLength();\n//        String dataString = new String(datas,0,len);\n//        System.out.println(\"数据是:\"+dataString);\n        System.out.println(\"数据是:\"+new String(datas,0,len));\n        //⑤关闭接收端\n        ds.close();\n    }\n}\n\n```\n\n# TCP通信原理\n\nTCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路\n\n一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信\nJava对基于TCP协议的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生io流来进行网络通信\n\nJava为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n## TCP发送数据\n\n### 发送数据的步骤：\n\n①创建客户端的Socket对象(Socket)\n②获取输出流，写数据\n③释放资源\n\n```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\n\npublic class day2TCP发送数据 {\n    public static void main(String[] args) throws IOException {\n        //①创建客户端的Socket对象(Socket)\n        //Socket(InetAddress address, int port)\n        //创建一个流套接字，并将其与指定的IP地址中的指定端口号连接起来。\n\n        //Socket s = new Socket(InetAddress.getByName(\"192.168.1.101\"),10000);\n\n        //Socket(String host, int port)\n        //创建一个流套接字，并将其与指定的主机上的指定端口号连接起来。\n        Socket s = new Socket(\"192.168.1.101\",10000);\n        //获取输出流，写数据\n        //getOutputStream()\n        //返回此套接字的输出流。\n        OutputStream os = s.getOutputStream();\n        os.write(\"hello,tcp,扬哥来啦\".getBytes());\n        //释放资源\n        s.close();\n    }\n}\n\n```\n\n## TCP接收数据\n\n### 接收数据的步骤：\n\n①创建服务器端的Socket对象(ServerSocket)\n②监听客户端连接，返回一个Socket对象\n③获取输入流，读数据，并把数据显示在控制台\n③释放资源\n\n```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class day3TCP接收数据 {\n    public static void main(String[] args) throws IOException {\n        //①创建服务器端的Socket对象(ServerSocket)\n        //ServerSocket(int port)\n        //创建一个服务器套接字，绑定到指定的端口。\n        ServerSocket ss = new ServerSocket(10000);\n        Socket s = ss.accept();\n        //②监听客户端连接，返回一个Socket对象\n        //accept()\n        //监听要对这个套接字作出的连接并接受它。\n        //③获取输入流，读数据，并把数据显示在控制台\n        InputStream is = s.getInputStream();\n        byte[] bys = new byte[1024];\n        int len = is.read(bys);\n        String data = new String(bys,0,len);\n        System.out.println(\"数据是:\"+data);\n        //释放资源\n        s.close();\n        ss.close();\n    }\n}\n\n```\n","tags":["Java","Java网络编程","网络编程"],"categories":["Java"]},{"title":"MySQL","url":"/2021/12/19/MySQL/","content":"\n# 1、初始MySQL\n\nJavaEE:企业级开发 web\n\n前端(页面:展示，数据!)\n\n后台(连接点:连接数据库JDBC，连接前端（控制，控制试图跳转，和给前端传递数据）)\n\n数据库（存数据，TXT，Excel，Word）\n\n> 只会写代码，学好数据库，基本混饭吃；\n\n>  操作系统，数据结构与算法，当一个不错的程序猿！\n\n>   离散数学，数字电路，体系结构，编译原理，实战经验，优秀程序猿\n\n## 1.1、为什么学习数据库\n1、岗位需求\n2、现在的世界，大数据时代~，得数据者得天下\n3、被迫需求：存数据\n```4、数据库是所有软件体系中最核心的存在   DBA```\n\n## 1.2、什么是数据库\n数据库(DB DataBase)\n\n概念：数据仓库，软件，安装在操作系统(windows,linux,mac.....)之上，SQL，可以存储大量数据。500万以内。\n\n作用：存储数据，管理数据\n\n## 1.3、数据库分类\n\n### 关系型数据库：（SQL）\n\n - MySQL、Oracle、SQL Server，DB2、SQLlite\n - 通过表和表之间，行和列之间的关系进行数据的存储。学员表，考勤表..\n\n### 非关系型数据库：（NoSQL）Not only SQL\n\n - Redis，MongoDB\n - 非关系型数据库，对象存储，通过对象的自身属性来决定。\n\n  ```DBMS（数据库管理系统）```\n\n - 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据\n - MySQL，数据库管理系统！\n\n## 1.4、MySQL\nMySQL是一个**关系型数据库管理系统**\n\n前世：瑞典MySQL AB公司\n\n今生：属于Oracle旗下产品\n\nMySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一\n\n开源的数据库软件~\n\n体积小，速度快，总体应用成本低，招人成本比较低，所有人必须会\n\n中小型网站、或者大型网站，集群\n\n官网：https://www.mysql.com\n\n5.7 稳\n8.0 用的还不是很多\n\n安装建议：\n1、尽量不要使用exe，注册表\n2、尽可能使用压缩包\n\n## 1.5、安装MySQL\n[详细过程点这里](https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&mid=2247484182&idx=1&sn=6a04b10ebac95da1a66abcefa1fa442c&chksm=ce6105b5f9168ca39ef07ff13f55700d4c6acfd5b5bfbe216eca72d6db3d7a09c312a4300f8e&mpshare=1&scene=23&srcid=1116lIgbSjubVZEBxi7cN154&sharer_sharetime=1637063633229&sharer_shareid=f9b31cd60ee31c509aad252419b6bf87#rd)\n1.解压\n2.把这个包放到自己的电脑环境目录下\n3.配置环境变量\n4.新建MySQL配置文件 ini结尾\n\n```sql\n[mysqld]\n#目录一定要换成自己的\nbasedir=D:\\MySQL5.7\\mysql-5.7.19-winx64\\\ndatadir=D:\\MySQL5.7\\mysql-5.7.19-winx64\\data\\\nport=3307\nskip-grant-tables\n```\n5.启动管理员模式下的cmd，运行所有的命令\n6.安装MySQL服务\n7.初始化数据库文件\n8.启动MySQL，进去修改密码\n9.进入MySQL通过命令行（-p后面不要加空格），修改密码（sql语句后面一定要加分号）\n\n### 问题：\n1、缺少组件 .dll\n2、命令输出\n\n```sql\nsc delete mysql\n```\n\n## 1.6、安装SQLyog\n1.无脑安装\n2.注册\n3.打开连接数据库\n4.新建一个数据库 school\n```每一个sqlyog的执行操作，本质就是对应了一个sql，可以在软件的历史记录中查看```\n5.新建一张表 student\n\n```sql\n字段:id,name,age\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b3ce6894b3064e15802c082c4658669f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n6.查看表\n7.自己尝试添加多条记录\n\n## 1.7、连接数据库\n命令行连接\n\n```sql\nmysql -u root -p123456 --连接数据库\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost'; --修改用户密码\nflush privileges; --刷新权限\n------------------------------------------------\n--所有的语句都使用分号结尾\nshow databases; --查看所有的数据库\nmysql> use school;  --切换数据库\nDatabase changed\nshow tables; --查看数据库中所有的表\ndescribe student; --显示数据库中所有的表的信息\ncreate database westos; --创建一个数据库\nexit; --退出链接\n--单行注释\n/*（sql的多行注释）\nhello\nworld\nmysql\n*/\n```\n**数据库 xxx 语言** CRUD 增删改查！ CV 程序猿  API程序猿 CRUD程序猿（业务）\nDDL 定义\nDML 操作\nDQL 查询\nDCL 控制\n\n# 2、操作数据库 （了解）\n操作数据库>操作数据库中的表>操作数据库中表的数据\n\n```MySQL语句不区分大小写```\n## 2.1、操作数据库\n\n### 1、创建数据库\n\n```sql\nCREATE DATABASE (IF NOT EXISTS) westos;\n```\n\n### 2、删除数据库\n\n```sql\nDROP DATABASE (IF EXISTS) hello；\n```\n\n### 3、使用数据库\n\n```sql\n--tab键的上面，如果你的表名或者字段名是一个特殊字符，就需要带\nUSE `westos`\n```\n### 4、查看数据库\n\n```sql\n SHOW DATABASES --查看所有的数据库\n```\n对比：sqlyog的可视化操作\n\n## 2.2、数据库的列类型\n\n> 数值\n\n - tinyint    十分小的数据 1个字节\n - smallint 较小的数据 2个字节\n - mediumint 中等大小的数据 3个字节\n - **int    标准的整数 4个字节** 常用的\n - bigint 较大的数据 8个字节\n - float 单精度浮点数 4个字节\n - double 双精度浮点数 8个字节\n - decimal 字符串形式的浮点数 ```金融计算的时候，一般使用 ```\n\n\n> 字符串\n\n - char 字符串固定大小的 0-255\n - **varchar 可变字符串 0-65535**\n - tinytext 微型文本 2^8-1\n - **text 文本串 2^16-1**\n\n\n> 事件日期\n\njava.util.Date\n\n - date     YYYY-MM-DD，日期\n - time      HH：mm：ss 时间格式\n - **datetime YYYY-MM-DD HH：mm：ss  最常用的时间格式**\n - **timestamp 时间戳 1970.1.1到现在的毫秒数！也较为常用**\n - year 年份标识\n\n> null\n\n - 没有值，未知\n - ==注意，不要使用null进行运算，结果为null==\n\n## 2.3、数据库的字段属性（重点）\n```Unsigned：```\n\n - 无符号的整数\n - 声明了该列不能为负数\n\n ```zerofill：```\n - 0填充的\n - 不足的位数，使用0来填充，in（3），5,005\n\n ```自增：```\n - 通常理解为自增，自动在上一条记录的基础上+1（默认）\n - 通常用来设计唯一的住建~index，必须是整数类型\n - 可以自定义设置主键自增的起始值和步长\n\n ```非空:```\n\n NUll 和 not null\n\n - 假设设置为not null，如果不给他赋值，就会报错\n - NUll，如果不填写值，默认就是null\n\n ```默认：```\n - 设置默认值\n - sex，默认值为男，如果不指定该列的值，则会有默认的值！\n\n 扩展：目前看看就行\n\n```sql\n/*每一个表都必须存在以下五个字段\nid 主键\n`version` 乐观锁\nis_delete 伪删除\ngmt_create 创建时间\ngmt_update 修改时间\n*/\n```\n## 2.4、创建数据库表\n```sql\n-- 目标：创建一个school数据库\n-- 创建学生表(列，字段) 使用SQL创建\n-- 学号int 登录密码varchar(20) 姓名，性别varchar(2),出生日期()\n-- 注意点，使用英文()，表的名称 和 字段 尽量使用``括起来\n-- AUTO_INCREMENT 自增\n-- 字符串使用单引号括起来\n-- 所有的语句后面加逗号 英文的 最后一个不用加\n-- PRIMARY KEY 主键 一般一个表只有一个\nCREATE DATABASE school\nCREATE TABLE IF NOT EXISTS `student` (\n\t`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n\t`name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n\t`pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码',\n\t`sex` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别',\n\t`birthday` DATETIME DEFAULT NULL COMMENT '出生日期',\n\t`address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址',\n\t`email` VARCHAR(50) DEFAULT  NULL COMMENT '邮箱',\n\tPRIMARY KEY(id)\n)ENGINE=INNODB DEFAULT CHARSET=utf8\n```\n格式：\n\n```sql\ncreate table[if not exists] `表名`(\n`字段名` 列类型 [属性][索引][注释],\n`字段名` 列类型 [属性][索引][注释],\n.......\n`字段名` 列类型 [属性][索引][注释],\n)[表类型][字符集][注释]\n```\n常用命令\n```sql\nSHOW CREATE DATABASE school -- 查看创建数据库的语句\nSHOW CREATE TABLE student -- 查看student数据表的定义语句\nDESC student -- 显示表的结构\n```\n## 2.5、数据库表的类型\nINNODB 默认使用\nMYISAM 早些年使用\n|            | MYISAM |    INNODN     |\n| :--------: | :----: | :-----------: |\n|  事务支持  | 不支持 |     支持      |\n| 数据行锁定 | 不支持 |     支持      |\n|  外键约束  | 不支持 |     支持      |\n|  全文索引  |  支持  |    不支持     |\n| 表空间大小 |  较小  | 较大，约为2倍 |\n\n常规使用操作：\n- MYISAM 节约空间，速度较快\n- INNODB 安全性高，事务的处理，多表多用户操作\n\n> 在物理空间存在的位置\n\n所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库\n本质还是文件的存储\n MySQL引擎在物理文件上的区别\n - INNODB在数据库表中只有一个*.frm文件，以及上级目录下的ipdata1文件\n - MYISAM对应文件\n\n  \t\t○*.frm     表结构定义文件\n  \t\t○*.MYD 数据文件(data)\n  \t\t○*.MYI   索引文件(index)\n\n\n>设置数据库表的字符集编码\n\n```sql\ncharset=utf8\n```\n不设置的话，会是MySQL默认的字符集编码（不支持中文）\n\nMySQL的默认编码是Latin1，不支持中文\n\n在my.ini中配置默认的编码\n\n```sql\ncharacter-set-server=utf8\n```\n## 2.6、修改和删除\n>修改\n\n\n>删除\n","tags":["Java","MySQL","数据库","JDBC"],"categories":["MySQL"]},{"title":"GUI编程","url":"/2021/12/19/GUI编程/","content":"\n# 1、简介\n\nGUI的核心技术: Swing AWT，界面不美观\n\n不流行的原因：\n- 因为界面不美观\n- 需要JRE环境\n\n为什么我们要学习？\n- 可以写出自己心中想要的小工具\n- 工作时候也可能维护swing界面\n- 了解MVC架构，了解监听\n\n# 2、AWT\n\n## 2.1、AWT介绍\n1. 包含了很多类和接口！GUI！\n2. 元素：窗口，按钮，文本窗\n3. java.awt\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1b7ccb47b20c4506b7b07987aab1c8ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n## 2.2、组件和容器\n### 1.Frame\n\n```java\npackage GUI.lesson1;\n\n//GUI的第一个界面\n\nimport java.awt.*;\n\npublic class TestFrame {\n    public static void main(String[] args) {\n        //Frame,JDK\n        Frame frame = new Frame(\"我的第一个Java图形界面窗口\");\n        //需要设置可见性\n        frame.setVisible(true);\n        //设置窗口大小\n        frame.setSize(400,400);\n        //设置背景颜色 Color\n        frame.setBackground(new Color(69, 108, 41));\n        //弹出的初始位置\n        frame.setLocation(200,200);\n        //设置大小固定\n        frame.setResizable(false);\n    }\n}\n```\n回顾封装:\n\n```java\npackage GUI.lesson1;\n\nimport java.awt.*;\n\npublic class TestFrame2 {\n    public static void main(String[] args) {\n        //展示多个窗口\n        MyFrame myFrame1 = new MyFrame(100, 100, 200, 200, Color.blue);\n        MyFrame myFrame2 = new MyFrame(300, 100, 200, 200, Color.yellow);\n        MyFrame myFrame3 = new MyFrame(100, 300, 200, 200, Color.red);\n        MyFrame myFrame4 = new MyFrame(300, 300, 200, 200, Color.MAGENTA);\n    }\n}\nclass MyFrame extends Frame{\n    static int id = 0; //可能有多个窗口，我们需要一个计数器\n    public MyFrame(int x,int y,int w,int h,Color color){\n        super(\"MyFrame\"+(++id));\n        setBackground(color);\n        setBounds(x,y,w,h);\n        setVisible(true);\n    }\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c3a389e6da744fb485778207760858ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_13,color_FFFFFF,t_70,g_se,x_16)\n### 2.面板Panel\n解决了关闭事件\n\n```java\npackage GUI.lesson1;\n\n//Panel 可以看成是一个空间，但是不能单独存在\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestPanel {\n    public static void main(String[] args) {\n        Frame frame = new Frame();\n        //布局的概念\n        Panel panel = new Panel();\n        //设置布局\n        frame.setLayout(null);\n        //坐标\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(new Color(0x81CE90));\n        //panel设置坐标，相对于frame\n        panel.setBounds(50,50,400,400);\n        panel.setBackground(new Color(0xDBE04452, true));\n        //frame.add(panel)\n        frame.add(panel);\n\n        frame.setVisible(true);\n        //监听事件，监听窗口关闭事件 System.exit(0)\n        //适配器模式\n        frame.addWindowListener(new WindowAdapter() {\n            //窗口点击关闭时候需要做的事情\n            @Override\n            public void windowClosing(WindowEvent e) {\n                //结束程序\n                System.exit(0);\n            }\n        });\n    }\n}\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a81b1bd36de6462b8572bff2e6f3b00a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_17,color_FFFFFF,t_70,g_se,x_16)\n## 2.3、布局管理器\n- 流式布局\n\n```java\npackage GUI.lesson1;\n\nimport java.awt.*;\n\npublic class TestFlowLayout {\n    public static void main(String[] args) {\n        Frame frame = new Frame();\n        //组件-按钮\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        //设置为流式布局\n//        frame.setLayout(new FlowLayout());\n        frame.setLayout(new FlowLayout(FlowLayout.LEFT));\n        frame.setSize(200,200);\n        frame.setVisible(true);\n        //把按钮添加上去\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n    }\n}\n\n```\n- 东西南北中\n\n```java\npackage GUI.lesson1;\n\nimport java.awt.*;\n\npublic class TestBorderLayout {\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"TestBorderLayout\");\n        Button east = new Button(\"east\");\n        Button west = new Button(\"west\");\n        Button south = new Button(\"south\");\n        Button north = new Button(\"north\");\n        Button center = new Button(\"center\");\n        frame.add(east,BorderLayout.EAST);\n        frame.add(west,BorderLayout.WEST);\n        frame.add(center,BorderLayout.CENTER);\n        frame.add(south,BorderLayout.SOUTH);\n        frame.add(north,BorderLayout.NORTH);\n        frame.setSize(200,200);\n        frame.setVisible(true);\n    }\n}\n\n```\n\n- 表格布局\n\n```java\npackage GUI.lesson1;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestGridLayout {\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"TestBorderLayout\");\n\n        Button btn1 = new Button(\"btn1\");\n        Button btn2 = new Button(\"btn2\");\n        Button btn3 = new Button(\"btn3\");\n        Button btn4 = new Button(\"btn4\");\n        Button btn5 = new Button(\"btn5\");\n        Button btn6 = new Button(\"btn6\");\n\n        frame.setLayout(new GridLayout(3,2));\n\n        frame.add(btn1);\n        frame.add(btn2);\n        frame.add(btn3);\n        frame.add(btn4);\n        frame.add(btn5);\n        frame.add(btn6);\n\n        frame.pack();//自动布局\n        frame.setVisible(true);\n\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n\n```\n### 练习\n![在这里插入图片描述](https://img-blog.csdnimg.cn/eb343bd24ed8448bba9330acc0b29168.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n**在每块空格处加上按钮**\n\n```java\npackage GUI.lesson1;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\n\npublic class Work {\n    public static void main(String[] args) {\n        //总frame窗 上下两层\n        Frame yang = new Frame(\"Yang\");\n        yang.setVisible(true);\n        yang.setSize(400,300);\n        yang.setLocation(300,400);\n        yang.setBackground(Color.CYAN);\n        yang.setLayout(new GridLayout(2,1));\n        //4个面板\n        Panel p1 = new Panel(new BorderLayout());\n        Panel p2 = new Panel(new GridLayout(2,1));\n        Panel p3 = new Panel(new BorderLayout());\n        Panel p4 = new Panel(new GridLayout(2,2));\n        p1.add(new Button(\"East-1\"),BorderLayout.EAST);\n        p1.add(new Button(\"West-1\"),BorderLayout.WEST);\n        p2.add(new Button(\"p2-btn-1\"));\n        p2.add(new Button(\"p2-btn-2\"));\n\n        p1.add(p2,BorderLayout.CENTER);\n\n        p3.add(new Button(\"East-2\"),BorderLayout.EAST);\n        p3.add(new Button(\"West-2\"),BorderLayout.WEST);\n        for (int i = 0; i < 4; i++) {\n            p4.add(new Button(\"for-\"+i));\n        }\n        p3.add(p4,BorderLayout.CENTER);\n\n        yang.add(p1);\n        yang.add(p3);\n\n        yang.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b6307b5440864059b6737fbd5b048b27.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmlvbGVudC1BeWFuZw==,size_15,color_FFFFFF,t_70,g_se,x_16)\n总结：\n- 1.Frame是一个顶级窗口\n- 2.Panel 无法单独显示，必须添加到某个容器中\n- 3.布局管理器\n     1.流式布局\n     2.东西南北中\n     3.表格布局\n     \n## 2.4、事件监听\n事件监听:当某个事情发生的时候，干什么？\n\n```java\npackage GUI.lesson2;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestActionEvent {\n    public static void main(String[] args) {\n        //按下按钮，触发一些事件\n        Frame frame = new Frame();\n        Button button = new Button();\n        //因为addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener\n        MyActionListener myActionListener = new MyActionListener();\n        button.addActionListener(myActionListener);\n        frame.add(button,BorderLayout.CENTER);\n        frame.pack();\n        frame.setVisible(true);\n        windowClose(frame);\n    }\n    //关闭窗体的事件\n    private static void windowClose(Frame frame){\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n//事件监听\nclass MyActionListener implements ActionListener{\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"aaa\");\n    }\n}\n```\n多个按钮共享一个事件\n\n```java\npackage GUI.lesson2;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TestActionTwo {\n    public static void main(String[] args) {\n        //两个按钮,实现同一个监听\n        //开始 停止\n        Frame frame = new Frame(\"开始-停止\");\n        Button button1 = new Button(\"start\");\n        Button button2 = new Button(\"stop\");\n\n        button2.setActionCommand(\"button-stop\");\n\n        MyMonitor myMonitor = new MyMonitor();\n        button1.addActionListener(myMonitor);\n        button2.addActionListener(myMonitor);\n\n        frame.add(button1,BorderLayout.NORTH);\n        frame.add(button2,BorderLayout.SOUTH);\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\nclass MyMonitor implements ActionListener{\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //\n        System.out.println(\"按钮被点击了:msg\"+e.getActionCommand());\n    }\n}\n\n```\n## 2.5、输入框TextField\n\n```java\npackage GUI.lesson2;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TestText01 {\n    public static void main(String[] args) {\n        //启动\n        new MyFrame();\n    }\n}\nclass MyFrame extends Frame{\n    public MyFrame(){\n        TextField textField = new TextField();\n        add(textField);\n        //监听这个文本框输入的文字\n        MyActionListener2 my2 = new MyActionListener2();\n        textField.addActionListener(my2);\n        //设置替换编码\n        textField.setEchoChar('*');\n        pack();\n        setVisible(true);\n    }\n}\nclass MyActionListener2 implements ActionListener{\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        TextField field = (TextField) e.getSource();//获得一些资源,返回一个对象\n         //获得输入框中的文本\n        System.out.println(field.getText());\n        field.setText(\"\");//null\n    }\n}\n\n```\n## 2.6、简易计算器，组合内部类回顾复习\n目前代码\n```java\npackage GUI.lesson2;\n\n//简易计算器\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TestCalc {\n    public static void main(String[] args) {\n        new Caculator();\n    }\n}\n//计算器类\nclass Caculator extends Frame{\n    public Caculator(){\n        //3个文本框\n        TextField num1 = new TextField(10);//字符数\n        TextField num2 = new TextField(10);//字符数\n        TextField num3 = new TextField(20);//字符数\n        //1个按钮\n        Button button = new Button(\"=\");\n        button.addActionListener(new MyCalculatorListener(num1,num2,num3));\n        //1个标签\n        Label label = new Label(\"+\");\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);\n        add(label);\n        add(num2);\n        add(button);\n        add(num3);\n\n        pack();\n        setVisible(true);\n    }\n}\n//监听器类\nclass MyCalculatorListener implements ActionListener{\n\n    private TextField num1,num2,num3;\n    public MyCalculatorListener(TextField num1,TextField num2,TextField num3){\n        this.num1 = num1;\n        this.num2 = num2;\n        this.num3 = num3;\n    }\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //1.获得加数和被加数\n        int n1 = Integer.parseInt(num1.getText()); //String类型\n        int n2 = Integer.parseInt(num2.getText()); //String类型\n        //2.将这两个值加法运算后放到第三个框\n        num3.setText(\"\"+(n1+n2));\n        //3.清楚前两个框\n        num1.setText(\"\");\n        num2.setText(\"\");\n    }\n}\n\n```\n","tags":["Java","GUI","图形化页面"],"categories":["Java"]},{"title":"1023 组个最小数 (20 分","url":"/2021/12/19/1023 组个最小数 (20 分/","content":"\n给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。\n\n现给定数字，请编写程序输出能够组成的最小的数。\n\n### 输入格式：\n\n输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。\n\n### 输出格式：\n\n在一行中输出能够组成的最小的数。\n\n### 输入样例：\n\n```in\n2 2 0 0 0 3 0 0 1 0\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n10015558\n\n结尾无空行\n```\n\n### 题解：\n\n```python\nz = {}\nscan = list(map(int,input().split()))\nif scan[0] != 0:\n    for i in range(1,10):\n        if scan[i] != 0:\n            print(i,end='')\n            flag = i\n            break\n    for i in range(0,10):\n        if i!=flag:\n            for j in range(0,scan[i]):\n                print(i,end='')\n        else:\n            for j in range(0,scan[i]-1):\n                print(i,end='')\nelse:\n    for i in range(0,10):\n        for j in range(0,scan[i]):\n            print(i,end='')\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1022 D进制的A+B (20 分)","url":"/2021/12/19/1022 D进制的A+B (20 分)/","content":"\n输入两个非负 10 进制整数 *A* 和 *B* (≤2^30−1)，输出 *A*+*B* 的 *D* (1<*D*≤10)进制数。\n\n### 输入格式：\n\n输入在一行中依次给出 3 个整数 *A*、*B* 和 *D*。\n\n### 输出格式：\n\n输出 *A*+*B* 的 *D* 进制数。\n\n### 输入样例：\n\n```in\n123 456 8\n```\n\n### 输出样例：\n\n```out\n1103\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n\tint a,b,num,d,i=0;\n\tscanf(\"%d %d %d\",&a,&b,&d);\n\tnum = a + b;\n\tint arr[100];\n\twhile(num>=d){\n\t\tarr[i] = num%d;\n\t\tnum /= d;\n\t\ti++;\n\t}\n\tarr[i] = num%d;\n\tfor(int j = i;j>=0;j--){\n\t\tprintf(\"%d\",arr[j]);\n\t}\n\treturn 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1021 个位数统计 (15 分)","url":"/2021/12/19/1021 个位数统计 (15 分)/","content":"\n\n$$\n给定一个 k 位整数\\\\ N=d_{k−1}\n​\n 10^{k−1}\n +⋯+d _1 10 \n^1\n +d_\n0\n​\n  \\\\(0≤d \ni\n​\n ≤9, i=0,⋯,k−1, d \nk−1\n​\n >0)\\\\请编写程序\\\\统计每种不同的个位数字出现的次数。\\\\例如：\\\\给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。\n$$\n\n### 输入格式：\n\n每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 *N*。\n\n### 输出格式：\n\n对 *N* 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在 *N* 中出现的次数 `M`。要求按 `D` 的升序输出。\n\n### 输入样例：\n\n```in\n100311\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n0:2\n1:3\n3:1\n\n结尾无空行\n```\n\n### 题解：\n\n```python\nn = input()\ndic = {}\nfor i in range(10):\n    if n.count(str(i)) > 0:\n        dic[i] = n.count(str(i))\nfor i in dic.keys():\n    print(str(i)+':'+str(dic[i]))\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1020 月饼 (25 分)","url":"/2021/12/19/1020 月饼 (25 分)/","content":"\n月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。\n\n注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。\n\n### 输入格式：\n\n每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N* 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 *D* 表示市场最大需求量。随后一行给出 *N* 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 *N* 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。\n\n### 输出格式：\n\n对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。\n\n### 输入样例：\n\n```in\n3 20\n18 15 10\n75 72 45\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n94.50\n\n结尾无空行\n```\n\n### 题解：\n\n```python\nkind, need = map(int, input().split())\namount = list(map(float, input().split()))\nprice = list(map(float, input().split()))\n\nans = 0\n\nrate = {i: price[i]/amount[i] for i in range(kind)}\n\norder = sorted(rate, key=lambda i:rate[i], reverse=True)\n\nfor i in order:\n    if amount[i] > need:\n        ans += rate[i]*need\n        break\n    else:\n        need -= amount[i]\n        ans += price[i]\n\nprint('{:.2f}'.format(ans))\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1019 数字黑洞 (20 分)","url":"/2021/12/19/1019 数字黑洞 (20 分)/","content":"\n给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。\n\n例如，我们从`6767`开始，将得到\n\n```\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n... ...\n```\n\n现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。\n\n### 输入格式：\n\n输入给出一个 (0,104) 区间内的正整数 *N*。\n\n### 输出格式：\n\n如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。\n\n### 输入样例 1：\n\n```in\n6767\n\n结尾无空行\n```\n\n### 输出样例 1：\n\n```out\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n\n结尾无空行\n```\n\n### 输入样例 2：\n\n```in\n2222\n\n结尾无空行\n```\n\n### 输出样例 2：\n\n```out\n2222 - 2222 = 0000\n\n结尾无空行\n```\n\n### 题解：\n\n```python\na = input().zfill(4)\nif a[0]==a[1]==a[2]==a[3]:\n    print(a+' - '+a+' = '+'0000')\nelse:\n    while True:\n        m = ''.join(sorted(a,reverse=True))\n        a = int(m) - int(m[::-1])\n        a = str(a).rjust(4,'0')\n        print('{} - {} = {}'.format(m,m[::-1],a))\n        if a == '6174':\n            break\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1018 锤子剪刀布 (20 分)","url":"/2021/12/19/1018 锤子剪刀布 (20 分)/","content":"\n大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：\n\n![FigCJB.jpg](https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg)\n\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n\n### 输入格式：\n\n输入第 1 行给出正整数 *N*（≤105），即双方交锋的次数。随后 *N* 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。`C` 代表“锤子”、`J` 代表“剪刀”、`B` 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。\n\n### 输出格式：\n\n输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。\n\n### 输入样例：\n\n```in\n10\nC J\nJ B\nC B\nB B\nB C\nC C\nC B\nJ B\nB C\nJ J\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n5 3 2\n2 3 5\nB B\n\n结尾无空行\n```\n\n### 题解：\n\n此方法暂时没找到问题所在，第一个测试点答案错误 18分 希望发现问题的朋友能够指点一下\n\n```python\nn = int(input())\ndicti = {'C':'J','J':'B','B':'C'}\ndicjia = {'C':0,'J':0,'B':0}\ndicyi = {'C':0,'J':0,'B':0}\nping = 0\nfor i in range(n):\n    jia,yi = input().split()\n    if jia == yi:\n        ping += 1\n    else:\n        if dicti[jia] == yi:\n            dicjia[jia] += 1\n        else:\n            dicyi[yi] += 1\njiasheng = sum(dicjia.values())\nyisheng = sum(dicyi.values())\nprint(jiasheng,ping,n-ping-jiasheng)\nprint(yisheng,ping,n-ping-yisheng)\nif ping == n:\n    print(\"B B\");\nelse:\n    d1 = sorted(dicjia.items(),key=lambda x:x[1],reverse=False)\n    d2 = sorted(dicyi.items(),key=lambda x:x[1],reverse=False)\n    print(d1[2][0],d2[2][0])\n```\n\n此方法为C语言 满分\n\n```c\n#include<stdio.h>\nint main()\n{\n    int N;\n    char x,y;\n    scanf(\"%d\\n\",&N);\n    int i, win=0, lose=0, dogfall=0;\n    int wc, wj, wb, lc, lj, lb;\n    wc=wb=wj=lc=lj=lb=0;\n    for(i=0;i<N;i++)\n    {\n         scanf(\"%c %c\",&x, &y);//x表示甲， y表示乙。\n        getchar();\n         if(x=='C')\n         {\n             if(y=='C')\n                dogfall++;\n             if(y=='J')\n                {win++;  wc++;}\n             if(y=='B')\n                {lose++; lb++;}\n         }\n         if(x=='J')\n         {\n             if(y=='J')\n                dogfall++;\n             if(y=='B')\n                {win++;  wj++;}\n             if(y=='C')\n                {lose++; lc++;}\n         }\n         if(x=='B')\n         {\n             if(y=='B')\n                dogfall++;\n             if(y=='C')\n                {win++; wb++;}\n             if(y=='J')\n                {lose++; lj++;}\n         }\n    }\n    printf(\"%d %d %d\\n\",win, dogfall, lose);\n    printf(\"%d %d %d\\n\",lose, dogfall, win);//甲输表示乙赢。\n    if(wc>wb&&wc>=wj) printf(\"C\");\n    else if(wb>=wc&&wb>=wj) printf(\"B\");\n    else if(wj>wb&&wj>wc) printf(\"J\");\n    printf(\" \");\n    if(lc>lb&&lc>=lj) printf(\"C\");//甲输表示乙赢。\n    else if(lb>=lc&&lb>=lj) printf(\"B\");\n    else if(lj>lb&&lj>lc) printf(\"J\");\n    printf(\"\\n\");\n\n    return 0;\n}\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1017 A除以B (20 分)","url":"/2021/12/19/1017 A除以B (20 分)/","content":"\n本题要求计算 *A*/*B*，其中 *A* 是不超过 1000 位的正整数，*B* 是 1 位正整数。你需要输出商数 *Q* 和余数 *R*，使得 *A*=*B*×*Q*+*R* 成立。\n\n### 输入格式：\n\n输入在一行中依次给出 *A* 和 *B*，中间以 1 空格分隔。\n\n### 输出格式：\n\n在一行中依次输出 *Q* 和 *R*，中间以 1 空格分隔。\n\n### 输入样例：\n\n```in\n123456789050987654321 7\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n17636684150141093474 3\n\n结尾无空行\n```\n\n### 题解：\n\n```python\na,b = map(int,input().split())\nq = a//b\nr = a%b\nprint(q,r)\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1016 部分A+B (15 分)","url":"/2021/12/19/1016 部分A+B (15 分)/","content":"\n正整数 *A* 的“*DA*（为 1 位整数）部分”定义为由 *A* 中所有 *DA* 组成的新整数 *PA*。例如：给定 *A*=3862767，*DA*=6，则 *A* 的“6 部分”*PA* 是 66，因为 *A* 中有 2 个 6。\n\n现给定 *A*、*DA*、*B*、*DB*，请编写程序计算 *PA*+*PB*。\n\n### 输入格式：\n\n输入在一行中依次给出 *A*、*DA*、*B*、*DB*，中间以空格分隔，其中 0<*A*,*B*<109。\n\n### 输出格式：\n\n在一行中输出 *PA*+*PB* 的值。\n\n### 输入样例 1：\n\n```in\n3862767 6 13530293 3\n```\n\n### 输出样例 1：\n\n```out\n399\n```\n\n### 输入样例 2：\n\n```in\n3862767 1 13530293 8\n```\n\n### 输出样例 2：\n\n```out\n0\n```\n\n### 题解：\n\n```python\nA,Da,B,Db = map(str,input().split())\ncishu1 = A.count(Da)\nif cishu1 == 0:\n    Da = 0\nelse:\n    Da = Da * cishu1\ncishu2 = B.count(Db)\nif cishu2 == 0:\n    Db = 0\nelse:\n    Db = Db * cishu2\nres = int(Da) + int(Db)\nprint(res)\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1015 德才论 (25 分)","url":"/2021/12/19/1015 德才论 (25 分)/","content":"\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n\n### 输入格式：\n\n输入第一行给出 3 个正整数，分别为：*N*（≤105），即考生总数；*L*（≥60），为录取最低分数线，即德分和才分均不低于 *L* 的考生才有资格被考虑录取；*H*（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 *H*，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 *L* 的考生也按总分排序，但排在第三类考生之后。\n\n随后 *N* 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。\n\n### 输出格式：\n\n输出第一行首先给出达到最低分数线的考生人数 *M*，随后 *M* 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n\n### 输入样例：\n\n```in\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n\tint de;\n\tint cai;\n\tint id;\n\tint rank; //标记档次 \n}stu;\nint cmp(const void *p,const void *q){//小于零p在q前 \n\tstu s1 = *(stu *)p;\n\tstu s2 = *(stu *)q;\n\tif(s1.rank!=s2.rank){//档次升序 \n\t\treturn s1.rank - s2.rank; \n\t}\n\telse if((s1.de+s1.cai)!=(s2.de+s2.cai)){//档次相同，先排总分 \n\t\treturn (s2.de+s2.cai)-(s1.de+s1.cai); //总分降序 \n\t}\n\telse if(s1.de!=s2.de){//总分相同，排德分 \n\t\treturn s2.de-s1.de;//德分降序 \n\t}\n\telse{\n\t\treturn s1.id - s2.id;//准考证升序 \n\t}\n}\nint main(){\n\tint num,zuidi,youxian;\n\tscanf(\"%d %d %d\",&num,&zuidi,&youxian);\n\tstu s[num];\n\tint cnt = 0;//及格人数\n\tfor(int i = 0;i < num;i ++){\n\t\tscanf(\"%d %d %d\",&s[i].id,&s[i].de,&s[i].cai);\n\t\tif(s[i].de>=zuidi&&s[i].cai>=zuidi){//所有及格人数\n\t\t\tcnt++;\n\t\t\tif(s[i].de>=youxian&&s[i].cai>=youxian){\n\t\t\t\ts[i].rank = 1; //德才全进 \n\t\t\t}\n\t\t\telse if(s[i].de>=youxian){\n\t\t\t\ts[i].rank = 2;//德胜才 \n\t\t\t} \n\t\t\telse if(s[i].de>=s[i].cai){\n\t\t\t\ts[i].rank = 3;//才德尽忘 \n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i].rank = 4;//啥也不是 \n\t\t\t} \n\t\t}else{\n            s[i].rank = 5;\n        }\n\t} \n\tprintf(\"%d\\n\",cnt);\n\tqsort(s,num,sizeof(stu),cmp);\n\tfor(int i = 0;i < cnt;i ++){\n\t\tprintf(\"%08d %d %d\\n\",s[i].id,s[i].de,s[i].cai);\n\t}\n\treturn 0;\n}\n```\n\n","tags":["PAT","结构体"],"categories":["PAT乙级"]},{"title":"1014 福尔摩斯的约会 (20 分)","url":"/2021/12/19/1014 福尔摩斯的约会 (20 分)/","content":"\n大侦探福尔摩斯接到一张奇怪的字条：\n\n```\n我们约会吧！ \n3485djDkxh4hhGE \n2984akDfkkkkggEdsb \ns&hgsfdk \nd&Hyscvnm\n```\n\n大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间`星期四 14:04`，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 `D`，代表星期四；第 2 对相同的字符是 `E` ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 `A` 到 `N` 表示）；后面两字符串第 1 对相同的英文字母 `s` 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n\n### 输入格式：\n\n输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。\n\n### 输出格式：\n\n在一行中输出约会的时间，格式为 `DAY HH:MM`，其中 `DAY` 是某星期的 3 字符缩写，即 `MON` 表示星期一，`TUE` 表示星期二，`WED` 表示星期三，`THU` 表示星期四，`FRI` 表示星期五，`SAT` 表示星期六，`SUN` 表示星期日。题目输入保证每个测试存在唯一解。\n\n### 输入样例：\n\n```in\n3485djDkxh4hhGE \n2984akDfkkkkggEdsb \ns&hgsfdk \nd&Hyscvnm\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\nTHU 14:04\n\n结尾无空行\n```\n\n### 题解：\n\n```python\ns1 = input()\ns2 = input()\ns3 = input()\ns4 = input()\nindex,day,hour,minute =0,0,0,0\ns12_hour_digit = []\nfor i in range(0,len(s1)):\n    if s1[i] == s2[i] and s1[i].isupper() and 64 < ord(s1[i].upper()) < 72:\n        day = s1[i]\n        index = i\n        break\nfor i in range(index+1,min(len(s1),len(s2))):\n    if s1[i] == s2[i] and (47<ord(s1[i])<58 or 64<ord(s1[i])<79):\n        hour = s1[i]\nDay = {'A':'MON','B':'TUE','C':'WED','D':'THU','E':'FRI','F':'SAT','G':'SUN'}\nday = Day[day]\nHour = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23}\nhour = Hour[hour]\nfor j in range(min(len(s3), len(s4))):\n    if s3[j] == s4[j] and s3[j].isalpha():\n        minute = j\n        break\nprint('{0} {1}:{2}'.format(day, str(hour).rjust(2, '0'), str(minute).rjust(2, '0')))\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1013 数素数 (20 分)","url":"/2021/12/19/1013 数素数 (20 分)/","content":"\n令 *Pi* 表示第 *i* 个素数。现任给两个正整数 *M*≤*N*≤104，请输出 *PM* 到 *PN* 的所有素数。\n\n### 输入格式：\n\n输入在一行中给出 *M* 和 *N*，其间以空格分隔。\n\n### 输出格式：\n\n输出从 *PM* 到 *PN* 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。\n\n### 输入样例：\n\n```in\n5 27\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n11 13 17 19 23 29 31 37 41 43\n47 53 59 61 67 71 73 79 83 89\n97 101 103\n\n结尾无空行\n```\n\n### 题解：\n\n```python\n\n#导入math库，以使用sqrt\nimport math\n#将输入的字符串按空格分割\na=input().split(' ')\n#开始的个数\nstart=int(a[0])\n#结束的个数\nend=int(a[1])\n \n#判断素数\ndef isprime(n):\n    if n==2 or n==3:\n        return True\n    if n%2==0 or n%3==0:\n        return False\n    for k in range(6,int(math.sqrt(n))+2,6):\n        if n%(k-1)==0 or n%(k+1)==0:\n            return False\n    return True\n \n#用来存放待输出的结果\nresults=[]\n#flag用来标记素数的个数\nflag=0\n#n用来判断素数\nn=2\n#素数个数等于end时循环结束\nwhile flag!=end:\n    if isprime(n):\n        flag=flag+1\n        #素数个数大于start时开始输出\n        if flag>=start:\n            #按格式进行对应的输出\n            if flag == end:\n                print(n, end='')\n            elif (flag + 1) % 10 == start:\n                print(n, end='\\n')\n            else:\n                print(n, end=' ')\n    n=n+1\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1012 数字分类 (20 分)","url":"/2021/12/19/1012 数字分类 (20 分)/","content":"\n给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：\n\n- *A*1 = 能被 5 整除的数字中所有偶数的和；\n- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；\n- *A*3 = 被 5 除后余 2 的数字的个数；\n- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；\n- *A*5 = 被 5 除后余 4 的数字中最大数字。\n\n### 输入格式：\n\n每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。\n\n### 输出格式：\n\n对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n\n若其中某一类数字不存在，则在相应位置输出 `N`。\n\n### 输入样例 1：\n\n```in\n13 1 2 3 4 5 6 7 8 9 10 20 16 18\n\n结尾无空行\n```\n\n### 输出样例 1：\n\n```out\n30 11 2 9.7 9\n\n结尾无空行\n```\n\n### 输入样例 2：\n\n```in\n8 1 2 4 5 6 7 9 16\n\n结尾无空行\n```\n\n### 输出样例 2：\n\n```out\nN 11 2 N 9\n\n结尾无空行\n```\n\n### 题解：\n\n```python\nnum = map(int , input().split()[1:])\nA1,A2,A3,A4,A5 = 0,0,0,0,0\nj,p,k = 0,0,0\nfor i in num:\n    if i%10 == 0:\n        A1 += i\n    if i%5 == 1:\n        if j == 0 or j == 2:\n            A2 += i\n            j = 1\n        else:\n            A2 -= i\n            j = 2\n    if i%5 == 2:\n        A3 += 1\n    if i%5 == 3:\n        p = p+1\n        k += i\n    if i%5 == 4:\n        if i > A5:\n            A5 = i\nif k != 0:\n    A4 = '%0.1f'%(k/p)\nelse:\n    A4 = 0\nif A1 == 0:\n    print('N',end=' ')\nelse:\n    print(A1,end=' ')\nif A2 == 0 and j == 0:\n    print('N',end=' ')\nelse:\n    print(A2,end=' ')\nif A3 == 0:\n    print('N',end=' ')\nelse:\n    print(A3,end=' ')\nif A4 == 0:\n    print('N',end=' ')\nelse:\n    print(A4,end=' ')\nif A5 == 0:\n    print('N')\nelse:\n    print(A5)\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1011 A+B 和 C (15 分)","url":"/2021/12/19/1011 A+B 和 C (15 分)/","content":"\n给定区间 [−231,231] 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。\n\n### 输入格式：\n\n输入第 1 行给出正整数 *T* (≤10)，是测试用例的个数。随后给出 *T* 组测试用例，每组占一行，顺序给出 *A*、*B* 和 *C*。整数间以空格分隔。\n\n### 输出格式：\n\n对每组测试用例，在一行中输出 `Case #X: true` 如果 *A*+*B*>*C*，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。\n\n### 输入样例：\n\n```in\n4\n1 2 3\n2 3 4\n2147483647 0 2147483646\n0 -2147483648 -2147483647\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\nCase #1: false\nCase #2: true\nCase #3: true\nCase #4: false\n\n结尾无空行\n```\n\n### 题解：\n\n```python\nn = int(input())\nlis = []\nfor i in range(0,n):\n    lis = list(map(int,input().split()))\n    if lis[0] + lis[1] > lis[2]:\n        print(\"Case #{}: true\".format(i+1))\n    else:\n        print(\"Case #{}: false\".format(i+1))\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1010 一元多项式求导 (25 分)","url":"/2021/12/19/1010 一元多项式求导 (25 分)/","content":"\n设计函数求一元多项式的导数。（注：x^n（*n*为整数）的一阶导数为*n**x**^(n*−1)。）\n\n### 输入格式:\n\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n\n### 输出格式:\n\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。\n\n### 输入样例:\n\n```in\n3 4 -5 2 6 1 -2 0\n\n结尾无空行\n```\n\n### 输出样例:\n\n```out\n12 3 -10 1 6 0\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n\tint xishu,zhishu,i=0;\n\twhile(scanf(\"%d %d\",&xishu,&zhishu)!=EOF){\n\t\tif(zhishu){\n\t\t\tif(i){\n\t\t\tprintf(\" %d %d\",xishu*zhishu,zhishu-1);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d %d\",xishu*zhishu,zhishu-1);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse if(i) break;\n\t\telse printf(\"0 0\");\n\t\t}\n\treturn 0;\n}\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1009 说反话 (20 分)","url":"/2021/12/19/1009 说反话 (20 分)/","content":"\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n\n### 输入格式：\n\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n\n### 输出格式：\n\n每个测试用例的输出占一行，输出倒序后的句子。\n\n### 输入样例：\n\n```in\nHello World Here I Come\n```\n\n### 输出样例：\n\n```out\nCome I Here World Hello\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\n#include<string.h>\nint main(){\n\tchar str[81];\n\tgets(str);\n\tint row = 0,col = 0;\n\tchar arr[81][81];\n\tint len = strlen(str);\n\tfor(int i = 0;i < len;i ++){\n\t\tif(str[i]!=' '){\n\t\t\tarr[row][col] = str[i];\n\t\t\tcol++;\n\t\t}else{\n\t\t\tarr[row][col] = '\\0';\n\t\t\trow++;\n\t\t\tcol = 0;\n\t\t}\n\t}\n\tfor(int i = row;i >= 0;i --){\n\t\tprintf(\"%s\",arr[i]);\n\t\tif(i!=0){\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1008 数组元素循环右移问题 (20 分)","url":"/2021/12/19/1008 数组元素循环右移问题 (20 分)/","content":"\n一个数组*A*中存有*N*（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移*M*（≥0）个位置，即将*A*中的数据由（*A*0*A*1⋯*A**N*−1）变换为（*A**N*−*M*⋯*A**N*−1*A*0*A*1⋯*A**N*−*M*−1）（最后*M*个数循环移至最前面的*M*个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n### 输入格式:\n\n每个输入包含一个测试用例，第1行输入*N*（1≤*N*≤100）和*M*（≥0）；第2行输入*N*个整数，之间用空格分隔。\n\n### 输出格式:\n\n在一行中输出循环右移*M*位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\n### 输入样例:\n\n```in\n6 2\n1 2 3 4 5 6\n\n结尾无空行\n```\n\n### 输出样例:\n\n```out\n5 6 1 2 3 4\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nvoid swap(int *s,int index,int num){\n    int j = 0;\n    for(int i = num;i < num+num-index; i ++){\n        s[i] = s[j];\n        j++;\n    }\n}\nint main(){\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    m = m % n;\n    int arr[n+1+m];\n    for(int i = 0;i < n;i ++){\n        scanf(\"%d\",&arr[i]);\n    }\n    swap(arr,m,n);\n    for(int i = n-m;i < n+n-m; i ++){\n        printf(\"%d\",arr[i]);\n        if(i!=n+n-m-1){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1007 素数对猜想 (20 分)","url":"/2021/12/19/1007 素数对猜想 (20 分)/","content":"\n让我们定义*d**n*为：*d**n*=*p**n*+1−*p**n*，其中*p**i*是第*i*个素数。显然有*d*1=1，且对于*n*>1有*d**n*是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n\n现给定任意正整数`N`(<105)，请计算不超过`N`的满足猜想的素数对的个数。\n\n### 输入格式:\n\n输入在一行给出正整数`N`。\n\n### 输出格式:\n\n在一行中输出不超过`N`的满足猜想的素数对的个数。\n\n### 输入样例:\n\n```in\n20\n\n结尾无空行\n```\n\n### 输出样例:\n\n```out\n4\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\n#include<math.h>\nint isPrime(int n){\n \tint flag = 1;\n \tfor(int i = 2;i <= (int)sqrt(n);i ++){\n \t\tif(n%i==0){\n \t\t\tflag = 0;\n \t\t}\n \t}\n    return flag;\n }\nint main()\n{\n \tint j = 0,count = 0,m;\n \tscanf(\"%d\",&m);\n \tint prime[m+1]; \n \tfor(int i = 2;i <= m;i ++){\n \t\tif(isPrime(i)){\n \t\t\tprime[j] = i;\n \t\t\tj++;\n \t\t} \n \t}\n \tfor(int i = 0;i<j-1;i++){\n \t\tif(prime[i+1]-prime[i] == 2){\n \t\t\tcount++;\n \t\t}\n \t}\n \tprintf(\"%d\",count);\n \treturn 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1006 换个格式输出整数 (15 分)","url":"/2021/12/19/1006 换个格式输出整数 (15 分)/","content":"\n让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。\n\n### 输出格式：\n\n每个测试用例的输出占一行，用规定的格式输出 *n*。\n\n### 输入样例 1：\n\n```in\n234\n\n结尾无空行\n```\n\n### 输出样例 1：\n\n```out\nBBSSS1234\n\n结尾无空行\n```\n\n### 输入样例 2：\n\n```in\n23\n\n结尾无空行\n```\n\n### 输出样例 2：\n\n```out\nSS123\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint ge = n%10;\n\tint shi = n/10%10;\n\tint bai = n/100;\n\tfor(int i = 0;i <bai;i++){\n\t\tprintf(\"B\");\n\t}\n\tfor(int i = 0;i <shi;i++){\n\t\tprintf(\"S\");\n\t}\n\tfor(int i = 1;i <=ge;i++){\n\t\tprintf(\"%d\",i);\n\t}\t\n\treturn 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1005 继续(3n+1)猜想 (25 分)","url":"/2021/12/19/1005 继续(3n+1)猜想 (25 分)/","content":"\n卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 *n*=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 *n*=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 *n* 为“关键数”，如果 *n* 不能被数列中的其他数字所覆盖。\n\n现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。\n\n### 输出格式：\n\n每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。\n\n### 输入样例：\n\n```in\n6\n3 5 6 7 8 11\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n7 6\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n\tint k,j=0,t[101],key[101],status[10000]={0},result[100]={0};\n\tscanf(\"%d\",&k);\n\tfor(int i = 0;i < k;i ++){\n\t\tscanf(\"%d\",&t[i]);\n\t\tint temp = t[i];\n\t\tif(status[temp] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\twhile(temp!=1){\n\t\t\tif(temp%2 == 0){\n\t\t\t\ttemp = temp/2;\n\t\t\t\tstatus[temp] = 1;\n\t\t\t}else{\n\t\t\t\ttemp = (3*temp+1)/2;\n\t\t\t\tstatus[temp] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < k;i ++){\n\t\tif(status[t[i]]==0){\n\t\t\tresult[j] = t[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(int i = 0;i < j;i ++){\n\t\tfor(int p = 0;p <j-i-1;p ++){\n\t\t\tif(result[p]<result[p+1]){\n\t\t\t\tint swap;\n\t\t\t\tswap = result[p];\n\t\t\t\tresult[p] = result[p+1];\n\t\t\t\tresult[p+1] = swap;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < j;i ++){\n\t\tprintf(\"%d\",result[i]);\n\t\tif(i!=j-1){\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1004 成绩排名 (20 分)","url":"/2021/12/19/1004 成绩排名 (20 分)/","content":"\n读入 *n*（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例，格式为\n\n```\n第 1 行：正整数 n\n第 2 行：第 1 个学生的姓名 学号 成绩\n第 3 行：第 2 个学生的姓名 学号 成绩\n  ... ... ...\n第 n+1 行：第 n 个学生的姓名 学号 成绩\n```\n\n其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n\n### 输出格式：\n\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n\n### 输入样例：\n\n```in\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\nMike CS991301\nJoe Math990112\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n\tstruct{\n\t\tchar name[20];\n\t\tchar id[20];\n\t\tint score;\n\t}stu[1000];\n\tint num;\t\n\tint min = 101;\n\tint index_min = 0;\n\tint max = -1;\n\tint index_max = 0;\n\tscanf(\"%d\",&num);\n\tfor(int i = 0;i < num;i ++){\n\t\tscanf(\"%s %s %d\",&stu[i].name,&stu[i].id,&stu[i].score); \n\t\tif(max<stu[i].score){\n\t\t\tmax = stu[i].score;\n\t\t\tindex_max = i;\n\t\t}\n\t\tif(min>stu[i].score){\n\t\t\tmin = stu[i].score;\n\t\t\tindex_min = i;\n\t\t}\n\t}\n\tprintf(\"%s %s\\n\",stu[index_max].name,stu[index_max].id);\n\tprintf(\"%s %s\",stu[index_min].name,stu[index_min].id);\n\treturn 0;\n} \n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1003 我要通过！ (20 分)","url":"/2021/12/19/1003 我要通过！ (20 分)/","content":"\n“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。\n\n得到“**答案正确**”的条件是：\n\n1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；\n2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；\n3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。\n\n现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (≤10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n\n### 输出格式：\n\n每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。\n\n### 输入样例：\n\n```in\n10\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\nAPT\nAPATTAA结尾无空行\n```\n\n### 输出样例：\n\n```out\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\n#include<string.h>\nint main()\n{    \n\tchar arr[100];    \n\tint n,i,j;       \n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t    int len,lp,lt,cp = 0,ct = 0,err = 0;        \n\t\tscanf(\"%s\",arr);                    \n\t\tlen=strlen(arr);        \n\t\tfor(i=0;i<len;i++){            \n\t\t\tif(arr[i]=='P'){                \n\t\t\t\tcp++;                \n\t\t\t\tlp=i;           \n\t\t\t}            \n\t\t\telse if(arr[i]=='T'){                \n\t\t\t\tct++;                \n\t\t\t\tlt=i;            \n\t\t\t}\n\t\t\telse if(arr[i]!='A'){                \n\t\t\t\terr++;            \n\t\t\t}        \n\t\t}        \n\t\tif(err!=0||ct!=1||cp!=1||lt-lp<=1){            \n\t\t\tprintf(\"NO\\n\");            \n\t\t\tcontinue;        \n\t\t}        \n\t\tint x=lp,y=lt-lp-1,z=len-lt-1;        \n\t\tif(x*y==z){            \n\t\t\tprintf(\"YES\\n\");        \n\t\t}        \n\t\telse{            \n\t\t\tprintf(\"NO\\n\");        \n\t\t}    \n\t}    \n\treturn 0;\n}\n\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1002 写出这个数 (20 分)","url":"/2021/12/19/1002 写出这个数 (20 分)/","content":"\n1002 写出这个数 (20 分)\n\n读入一个正整数 *n*，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例，即给出自然数 *n* 的值。这里保证 *n* 小于 10100。\n\n### 输出格式：\n\n在一行内输出 *n* 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n\n### 输入样例：\n\n```in\n1234567890987654321123456789\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\nyi san wu\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\n#include<string.h>\nint main(){\n    char a[100];\n    int num = 0,ge,shi,bai;\n    scanf(\"%s\",&a);\n    for(int i = 0;i < strlen(a);i++){\n        num = num + a[i] - '0';\n    }\n    //因为保证 n 小于 10的100次方，假设每个数字都是9，最大也只能是900，不会超过一千，所以这里只用考虑百位数，十位数，个位数\n    char *py[] = {\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"};\n    if (num>=100){\n        ge = num%10;\n        shi = num/10%10;\n        bai = num/100;\n        printf(\"%s \",py[bai]);\n        printf(\"%s \",py[shi]);\n        printf(\"%s\",py[ge]);\n    }\n    else if(num>=10){\n        ge = num%10;\n        shi = num/10;\n        printf(\"%s \",py[shi]);\n        printf(\"%s\",py[ge]);\n    }\n    else{\n        printf(\"%s\",py[num]);\n    }\n    return 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"1001 害死人不偿命的(3n+1)猜想 (15 分)","url":"/2021/12/19/1001 害死人不偿命的(3n+1)猜想 (15 分)/","content":"\n卡拉兹(Callatz)猜想：\n\n对任何一个正整数 *n*，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3*n*+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 *n*=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3*n*+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 *n*，简单地数一下，需要多少步（砍几下）才能得到 *n*=1？\n\n### 输入格式：\n\n每个测试输入包含 1 个测试用例，即给出正整数 *n* 的值。\n\n### 输出格式：\n\n输出从 *n* 计算到 1 需要的步数。\n\n### 输入样例：\n\n```in\n3\n\n结尾无空行\n```\n\n### 输出样例：\n\n```out\n5\n\n结尾无空行\n```\n\n### 题解：\n\n```c\n#include<stdio.h>\nint main(){\n    int n,count=0;\n    scanf(\"%d\",&n);\n    while(n>1){\n        if(n%2!=0){\n            n = (3*n + 1)/2;\n            count++;\n        }\n        else{\n            n = n/2;\n            count++;\n        }\n    }\n    printf(\"%d\",count);\n    return 0;\n}\n```\n\n","tags":["PAT"],"categories":["PAT乙级"]},{"title":"python刷题笔记","url":"/2021/12/13/python刷题笔记/","content":"\n# 对字典按照值的顺序排序\n\n```python\ndic = {\"red\":5,\"or\":6}\nnew_dic = sorted(dic.items(),key= lambda x:x[1],reverse=True)\n```\n\n<font color = \"pink\">注意：变成列表嵌套元祖，需要进行解包操作</font>\n\n#  如何对元祖进行解包\n\n<font color = \"orange\">一对一解包：</font>\n\n```python\nresult_n,result_num = dic[0]\nprint(result_n)\n```\n\n这样既可取出两个元素元祖内的两个元素\n\n# 删除字符串中的字符\n\n**删除字符串两端或一段的多种字符**\n\nlist.strip(字符):删除字符串两端的一种或多种字符\n\n```python\ns = \"abbbmmmcccaaabb\"\ns1 = s.strip('abc')\nprint(s1) #mmm\n```\n\nlist.lstrip(字符)：删除字符串左端的一种或多种字符\n\nlist.rstrip(字符)：删除字符串右端的一种或多种字符\n\nstr.replace(被替换的字符,\")\n\n```python\ns = 'abc:abc'\ns1 = s.replace(':','')\nprint(s1) #abcabc\n```\n\n# enumerate遍历列表同时获取元素及下表\n\n```python\nfor i,item in enumerate(List):\n    print(i,item)\n```\n\n# 强制退出python程序\n\n需要在内循环里结束两个循环时，可以用强制退出程序\n\n```python\nimport sys\nchouma,cishu = map(int,input().split())\nd = 0\nfor i in range(cishu):\n    n1,b,t,n2 = map(int,input().split())\n    if chouma >= t:\n        if b == 0:\n            if n2<n1:\n                chouma += t\n                print('Win {}!  Total = {}.'.format(t,chouma))\n            else:\n                chouma -= t\n                print('Lose {}.  Total = {}.'.format(t,chouma))\n                if chouma == 0:\n                    print('Game Over.')\n                    sys.exit()\n        else:\n            if n2>n1:\n                chouma += t\n                print('Win {}!  Total = {}.'.format(t,chouma))\n            else:\n                chouma -= t\n                print('Lose {}.  Total = {}.'.format(t,chouma))\n                if chouma == 0:\n                    print('Game Over.')\n                    sys.exit()\n    else:\n        print('Not enough tokens.  Total = {}.'.format(chouma))\n```\n\n导入sys包 sys.exit()\n\n# 不足位数补零\n\n**Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。**\n**Python rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。**\n\n<font color=\"orange\">zfill()方法语法：</font>\nstr.zfill(width)\nwidth – 指定字符串的长度。原字符串右对齐，前面填充0。\n\n<font color=\"orange\">rjust()方法语法：</font>\nstr.rjust(width[, fillchar])\nwidth – 指定填充指定字符后中字符串的总长度.\nfillchar – 填充的字符，默认为空格。\n\n","tags":["python","笔记"],"categories":["python"]},{"title":"Hello World","url":"/2021/12/13/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]